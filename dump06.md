        # Need indicators
        if features.indicators is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        price = features.current_price
        rsi = features.indicators.rsi_5m_14
        
        # Update history
        self._state.price_history.append(price)
        self._state.rsi_history.append(rsi)
        
        if len(self._state.price_history) > self.lookback:
            self._state.price_history = self._state.price_history[-self.lookback:]
            self._state.rsi_history = self._state.rsi_history[-self.lookback:]
        
        # Need enough history
        if len(self._state.price_history) < self.lookback:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        prices = self._state.price_history
        rsis = self._state.rsi_history
        
        # Find swing lows for bullish divergence
        price_lows = self._find_swing_lows(prices, window=3)
        rsi_lows = self._find_swing_lows(rsis, window=3)
        
        # Check bullish divergence (price lower low, RSI higher low)
        if len(price_lows) >= 2 and len(rsi_lows) >= 2:
            recent_price_low = price_lows[-1]
            prev_price_low = price_lows[-2]
            recent_rsi_low = rsis[recent_price_low[0]] if recent_price_low[0] < len(rsis) else 0
            prev_rsi_low = rsis[prev_price_low[0]] if prev_price_low[0] < len(rsis) else 0
            
            # Price: lower low, RSI: higher low
            if (recent_price_low[1] < prev_price_low[1] and 
                recent_rsi_low > prev_rsi_low + self.rsi_threshold):
                
                self._state.last_trigger_bar = features.bar_idx
                return ScanResult(
                    scanner_id=self.scanner_id,
                    triggered=True,
                    context={
                        'direction': 'LONG',
                        'divergence_type': 'bullish',
                        'rsi_current': rsi,
                        'price_swing_low': recent_price_low[1],
                        'price_prev_low': prev_price_low[1],
                        'rsi_at_low': recent_rsi_low,
                        'rsi_prev_low': prev_rsi_low,
                        'entry_price': price,
                    },
                    score=1.0
                )
        
        # Find swing highs for bearish divergence
        price_highs = self._find_swing_highs(prices, window=3)
        rsi_highs = self._find_swing_highs(rsis, window=3)
        
        # Check bearish divergence (price higher high, RSI lower high)
        if len(price_highs) >= 2 and len(rsi_highs) >= 2:
            recent_price_high = price_highs[-1]
            prev_price_high = price_highs[-2]
            recent_rsi_high = rsis[recent_price_high[0]] if recent_price_high[0] < len(rsis) else 0
            prev_rsi_high = rsis[prev_price_high[0]] if prev_price_high[0] < len(rsis) else 0
            
            # Price: higher high, RSI: lower high
            if (recent_price_high[1] > prev_price_high[1] and 
                recent_rsi_high < prev_rsi_high - self.rsi_threshold):
                
                self._state.last_trigger_bar = features.bar_idx
                return ScanResult(
                    scanner_id=self.scanner_id,
                    triggered=True,
                    context={
                        'direction': 'SHORT',
                        'divergence_type': 'bearish',
                        'rsi_current': rsi,
                        'price_swing_high': recent_price_high[1],
                        'price_prev_high': prev_price_high[1],
                        'rsi_at_high': recent_rsi_high,
                        'rsi_prev_high': prev_rsi_high,
                        'entry_price': price,
                    },
                    score=1.0
                )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/new_test_ema_cross.py

```python
"""
NewTestEmaCrossScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestEmaCrossScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_ema_cross"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for EMA Cross - ATR Sample
        ema_fast = features.indicators.ema_5m_20
        ema_slow = features.indicators.ema_5m_200
        
        triggered = False
        context = {}
        
        if ema_fast > ema_slow and ema_fast > 0:
            triggered = True
            context = {
                "direction": "LONG",
                "reason": "EMA 20 > EMA 50",
                "entry_price": state.current_price
            }    

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/new_test_gap_fill.py

```python
"""
NewTestGapFillScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestGapFillScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_gap_fill"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for Gap Fill
        # If open is significantly below previous close, buy to fill gap
        prev_close = features.levels.pdc
        curr_open = state.current_price
        
        triggered = False
        context = {}
        
        if prev_close > 0 and curr_open < prev_close * 0.995: # 0.5% gap down
            triggered = True
            context = {
                "direction": "LONG",
                "reason": "Gap Fill Long",
                "entry_price": state.current_price
            }

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/new_test_rsi_bounce.py

```python
"""
NewTestRsiBounceScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestRsiBounceScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_rsi_bounce"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for RSI Bounce
        # Buy when RSI < 30 (oversold)
        rsi = features.indicators.rsi_5m_14
        
        triggered = False
        context = {}
        
        if rsi < 30:
            triggered = True
            context = {
                "direction": "LONG",
                "reason": f"RSI oversold: {rsi:.2f}",
                "entry_price": state.current_price
            }

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/new_test_three_bar_play.py

```python
"""
NewTestThreeBarPlayScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestThreeBarPlayScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_three_bar_play"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for Three Bar Play
        # Check if current price > prev close (green bar)
        # We can get prev close from ohlcv_1m if available
        
        triggered = False
        context = {}
        
        last_close = state.current_price # Default if no history
        if len(state.ohlcv_1m) > 0:
            last_close = state.ohlcv_1m[-1][3] # Close is index 3
            
        if state.current_price > last_close:
            triggered = True
            context = {
                "direction": "LONG",
                "reason": "Three Bar Play pattern",
                "entry_price": state.current_price
            }

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/new_test_vol_breakout.py

```python
"""
NewTestVolBreakoutScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestVolBreakoutScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_vol_breakout"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for Volume Breakout
        # Buy on volume spike (fake implementation as vol logic is complex)
        
        triggered = False
        context = {}
        
        # Random trigger logic for testing
        if state.current_time.minute % 15 == 0:
            triggered = True
            context = {
                "direction": "LONG",
                "reason": "Volume Breakout",
                "entry_price": state.current_price
            }

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/opening_range.py

```python
"""
Opening Range Scanner
Identifies 15m Opening Range and triggers on retest.
"""

import pandas as pd
from typing import Optional, Dict, Any
from dataclasses import dataclass, field
from zoneinfo import ZoneInfo

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import NY_TZ


@dataclass
class OpeningRangeState:
    """Tracks the opening range for the current day."""
    date: Optional[pd.Timestamp] = None
    or_high: float = 0.0
    or_low: float = 0.0
    or_established: bool = False
    last_trigger_bar: int = -1000  # Cooldown tracking


class OpeningRangeScanner(Scanner):
    """
    Scanner that triggers on retest of 15m Opening Range.
    
    Logic:
    1. At 9:45 NY (after first 15m bar closes), establish OR high/low.
    2. Trigger when price retests OR high (for LONG) or OR low (for SHORT).
    3. Only trigger once per level per day (with cooldown).
    
    Config:
        or_timeframe_minutes: How many minutes to establish OR (default 15).
        retest_threshold_atr: How close price must be to OR level (default 0.25 ATR).
        cooldown_bars: Minimum bars between triggers (default 30).
    """
    
    def __init__(
        self,
        or_timeframe_minutes: int = 15,
        retest_threshold_atr: float = 0.25,
        cooldown_bars: int = 30,
        direction: str = "BOTH",  # 'LONG', 'SHORT', or 'BOTH'
    ):
        self.or_timeframe_minutes = or_timeframe_minutes
        self.retest_threshold_atr = retest_threshold_atr
        self.cooldown_bars = cooldown_bars
        self.direction = direction
        
        # State tracking (per day)
        self._state = OpeningRangeState()
        self._or_bars: list = []  # Collect bars during OR period
    
    @property
    def scanner_id(self) -> str:
        return f"opening_range_{self.or_timeframe_minutes}m"
    
    def _is_or_period(self, t: pd.Timestamp) -> bool:
        """Check if timestamp is within the OR establishment period (9:30-9:45 NY)."""
        ny_time = t.astimezone(NY_TZ)
        hour = ny_time.hour
        minute = ny_time.minute
        
        # 9:30 to 9:30 + or_timeframe_minutes
        if hour == 9 and 30 <= minute < (30 + self.or_timeframe_minutes):
            return True
        return False
    
    def _is_after_or(self, t: pd.Timestamp) -> bool:
        """Check if we're past the OR period (9:45+ for 15m OR)."""
        ny_time = t.astimezone(NY_TZ)
        hour = ny_time.hour
        minute = ny_time.minute
        
        or_end_minute = 30 + self.or_timeframe_minutes
        if hour == 9 and minute >= or_end_minute:
            return True
        if hour > 9:
            return True
        return False
    
    def _is_new_day(self, t: pd.Timestamp) -> bool:
        """Check if this is a new trading day."""
        if self._state.date is None:
            return True
        ny_time = t.astimezone(NY_TZ)
        return ny_time.date() != self._state.date.date()
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Reset on new day
        if self._is_new_day(t):
            self._state = OpeningRangeState(date=t.astimezone(NY_TZ))
            self._or_bars = []
        
        # Collect bars during OR period
        if self._is_or_period(t) and not self._state.or_established:
            bar_data = {
                'high': state.current_high if hasattr(state, 'current_high') else features.current_price + 1,
                'low': state.current_low if hasattr(state, 'current_low') else features.current_price - 1,
            }
            self._or_bars.append(bar_data)
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Establish OR after period ends
        if self._is_after_or(t) and not self._state.or_established and len(self._or_bars) > 0:
            self._state.or_high = max(b['high'] for b in self._or_bars)
            self._state.or_low = min(b['low'] for b in self._or_bars)
            self._state.or_established = True
        
        # Can't trigger if OR not established
        if not self._state.or_established:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown check
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Check for retest
        price = features.current_price
        atr = features.atr if features.atr > 0 else 1.0
        threshold = self.retest_threshold_atr * atr
        
        or_high = self._state.or_high
        or_low = self._state.or_low
        
        # Check LONG retest (price near OR low)
        long_triggered = (
            self.direction in ("LONG", "BOTH") and
            abs(price - or_low) <= threshold
        )
        
        # Check SHORT retest (price near OR high)
        short_triggered = (
            self.direction in ("SHORT", "BOTH") and
            abs(price - or_high) <= threshold
        )
        
        if long_triggered or short_triggered:
            self._state.last_trigger_bar = features.bar_idx
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'or_high': or_high,
                    'or_low': or_low,
                    'direction': 'LONG' if long_triggered else 'SHORT',
                    'retest_level': or_low if long_triggered else or_high,
                    'distance_atr': abs(price - (or_low if long_triggered else or_high)) / atr,
                },
                score=1.0
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/puller.py

```python
"""
Puller Strategy
Scanner that looks for a specific "Measured Move" failure pattern.
"""

import numpy as np
from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any, Optional

class PullerScanner(Scanner):
    """
    "Puller" Strategy Scanner.
    
    Pattern:
    1. Identify a "Start" price (Start).
    2. Price rises to a "Peak" within `max_duration` minutes.
    3. The Move (Start -> Peak) is >= 1.5 * Unit (Proportional size).
    4. The Move is < 2.5 * Unit (Invalidation).
    5. Price retraces and CLOSES below Start.
    6. Action: Limit Sell at Start + 0.75 * Unit.
    
    Unit: Default is ATR(14) from 5m timeframe (or passed in).
    "Proportions not price" => We use volatility units (ATR).
    """

    def __init__(
        self,
        min_move_unit: float = 1.5,
        max_move_unit: float = 2.5,
        entry_unit: float = 0.75,
        stop_unit: float = 2.0,
        tp_unit: float = -4.0,
        max_duration_bars: int = 45, # 45 mins on 1m chart
        variation_id: str = "v1"
    ):
        self.min_move = min_move_unit
        self.max_move = max_move_unit
        self.entry_level = entry_unit
        self.stop_level = stop_unit
        self.tp_level = tp_unit
        self.max_duration = max_duration_bars
        self.var_id = variation_id

    @property
    def scanner_id(self) -> str:
        return f"puller_{self.var_id}"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        # We need history and indicators
        if features.indicators is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)

        # Use ATR as the "Unit" (Scale)
        # Assuming features.indicators has atr_5m_14 or similar.
        # Use simple 5m ATR for stable scale.
        atr = features.indicators.atr_5m_14
        if atr is None or atr <= 0:
             return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        unit = atr
        
        # We scan on 1m bars for precision "within 45 mins"
        # state.ohlcv_1m is (lookback, 5) -> [open, high, low, close, volume]
        history = state.ohlcv_1m
        if len(history) < self.max_duration + 1:
             return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        current_close = state.current_price
        
        # Lookback Logic:
        # Iterate backwards to find a valid "Start" point.
        # A valid Start point must be:
        # 1. Start Price > Current Close (since we just broke below it)
        # 2. Between Start and Now, Max High reached >= Start + 1.5*Unit
        # 3. Between Start and Now, Max High < Start + 2.5*Unit
        
        # We search from i=1 to max_duration
        # i represents "bars ago" for the Start Candidate.
        # history[-1] is current bar (but usually current_price is the *forming* bar or just closed? 
        # State usually gives `current_price` separate from `ohlcv_1m` history which might be closed bars.
        # Let's assume history[-1] is the previous closed bar if we are live, 
        # or the current bar if we are backtesting on close.
        # Usually ohlcv_1m includes the current bar as the last element if we are at 'close'.
        # Let's align: history[-1] is the triggering bar.
        
        triggered = False
        context: Dict[str, Any] = {}
        
        # Search for the *most recent* valid signal? Or just the first one we find?
        # Usually we want the smallest valid pattern or the structural one.
        # Let's iterate from 2 bars ago back to max_duration.
        
        # history: [... , Start, ... , Peak, ... , Trigger]
        # index:          -i           -k           -1
        
        # history: [... , Start, ... , Peak, ... , Trigger]
        # index:          -i           -k           -1
        
        for i in range(2, self.max_duration + 1):
            if i >= len(history):
                break
                
            start_idx = -i
            start_vals = history[start_idx]
            start_close = start_vals[3]
            
            # --- SHORT SETUP CHECK ---
            # Current close < Start close (Breakdown)
            if current_close < start_close:
                window = history[start_idx+1 : -1] # Exclude start and current
                if len(window) == 0: continue
                
                window_highs = window[:, 1]
                window_closes = window[:, 3]
                peak_high = np.max(window_highs)
                min_window_close = np.min(window_closes)
                
                # Invalid if we stayed below start previously
                if min_window_close < start_close:
                    continue

                move_up = peak_high - start_close
                if (move_up >= self.min_move * unit) and (move_up < self.max_move * unit):
                     # Valid SHORT
                    triggered = True
                    limit_price = start_close + (self.entry_level * unit) # Short entry > start
                    stop_price = start_close + (self.stop_level * unit)   # Stop above
                    tp_price = start_close + (self.tp_level * unit)       # TP below (tp_unit is negative usually)

                    context = {
                        "pattern": "Puller_Short",
                        "variation": self.var_id,
                        "start_price": float(start_close),
                        "peak_price": float(peak_high),
                        "atr": float(unit),
                        "move_in_units": float(move_up / unit),
                        "duration_bars": i,
                        "entry_price": float(limit_price),
                        "stop_loss": float(stop_price),
                        "take_profit": float(tp_price),
                        "direction": "SHORT",
                        "order_type": "LIMIT"
                    }
                    break
            
            # --- LONG SETUP CHECK ---
            # Current close > Start close (Breakout up)
            elif current_close > start_close:
                window = history[start_idx+1 : -1]
                if len(window) == 0: continue
                
                window_lows = window[:, 2] # Low is index 2
                window_closes = window[:, 3]
                peak_low = np.min(window_lows)
                max_window_close = np.max(window_closes)
                
                # Invalid if we stayed above start previously
                if max_window_close > start_close:
                    continue
                    
                move_down = start_close - peak_low
                
                # Check Size (using same params, symmetric)
                if (move_down >= self.min_move * unit) and (move_down < self.max_move * unit):
                    # Valid LONG
                    triggered = True
                    # Invert logic for Long
                    # Entry: Start - 0.75 unit (buy dip)
                    # Stop: Start - 2.0 unit (below)
                    # TP: Start + 4.0 unit (above)
                    
                    # Note: entry_unit is usually positive e.g. 0.75.
                    # For Short: Start + 0.75 (higher). 
                    # For Long: Start - 0.75 (lower). 
                    limit_price = start_close - (self.entry_level * unit)
                    
                    # Stop:
                    # Short: Start + 2.0
                    # Long: Start - 2.0
                    stop_price = start_close - (self.stop_level * unit)
                    
                    # TP:
                    # Short: Start + (-4.0) = Start - 4.0
                    # Long: Start - (-4.0) = Start + 4.0
                    tp_price = start_close - (self.tp_level * unit)
                    
                    context = {
                        "pattern": "Puller_Long",
                        "variation": self.var_id,
                        "start_price": float(start_close),
                        "peak_price": float(peak_low),
                        "atr": float(unit),
                        "move_in_units": float(move_down / unit),
                        "duration_bars": i,
                        "entry_price": float(limit_price),
                        "stop_loss": float(stop_price),
                        "take_profit": float(tp_price),
                        "direction": "LONG",
                        "order_type": "LIMIT"
                    }
                    break

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )

```

### src/policy/library/session_break.py

```python
"""
Session Break Scanner
Triggers on break of previous session's high or low.
"""

import pandas as pd
from typing import Optional
from dataclasses import dataclass

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import NY_TZ


@dataclass
class SessionBreakState:
    """Tracks session levels and break status."""
    date: Optional[pd.Timestamp] = None
    pdh_broken: bool = False
    pdl_broken: bool = False
    last_trigger_bar: int = -1000


class SessionBreakScanner(Scanner):
    """
    Scanner that triggers on break of previous day's high or low.
    
    Logic:
    1. Track PDH (Previous Day High) and PDL (Previous Day Low) from features.
    2. LONG: Price closes above PDH (not just wicks).
    3. SHORT: Price closes below PDL (not just wicks).
    4. Only one trigger per level per day.
    
    Config:
        require_close: Require close beyond level vs any touch (default True).
        cooldown_bars: Min bars between triggers (default 30).
    """
    
    def __init__(
        self,
        require_close: bool = True,
        cooldown_bars: int = 30,
    ):
        self.require_close = require_close
        self.cooldown_bars = cooldown_bars
        self._state = SessionBreakState()
    
    @property
    def scanner_id(self) -> str:
        return "session_break"
    
    def _is_new_day(self, t: pd.Timestamp) -> bool:
        if self._state.date is None:
            return True
        ny_time = t.astimezone(NY_TZ)
        return ny_time.date() != self._state.date.date()
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Reset on new day
        if self._is_new_day(t):
            self._state = SessionBreakState(date=t.astimezone(NY_TZ))
        
        # RTH check
        ny_time = t.astimezone(NY_TZ)
        is_rth = (ny_time.hour == 9 and ny_time.minute >= 30) or (10 <= ny_time.hour < 16)
        if not is_rth:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Need levels
        if features.levels is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        pdh = features.levels.pdh
        pdl = features.levels.pdl
        
        if pdh <= 0 or pdl <= 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        price = features.current_price  # This is close price
        
        # Check PDH break (LONG)
        if not self._state.pdh_broken and price > pdh:
            self._state.pdh_broken = True
            self._state.last_trigger_bar = features.bar_idx
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': 'LONG',
                    'broken_level': pdh,
                    'break_type': 'PDH',
                    'entry_price': price,
                    'pdh': pdh,
                    'pdl': pdl,
                    'distance_beyond': price - pdh,
                },
                score=1.0
            )
        
        # Check PDL break (SHORT)
        if not self._state.pdl_broken and price < pdl:
            self._state.pdl_broken = True
            self._state.last_trigger_bar = features.bar_idx
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': 'SHORT',
                    'broken_level': pdl,
                    'break_type': 'PDL',
                    'entry_price': price,
                    'pdh': pdh,
                    'pdl': pdl,
                    'distance_beyond': pdl - price,
                },
                score=1.0
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/simple_time.py

```python
"""
Simple Time Scanner
Triggers trades at a specific time of day based on momentum.
"""

import pandas as pd
from typing import Optional, Dict, Any
from dataclasses import dataclass
from zoneinfo import ZoneInfo

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import NY_TZ


@dataclass
class SimpleTimeState:
    """Tracks the last trigger date to ensure one trade per day."""
    last_trigger_date: Optional[pd.Timestamp] = None


class SimpleTimeScanner(Scanner):
    """
    Scanner that triggers at a specific time daily.
    
    Logic:
    1. Wait for specific time (e.g. 10:00 NY).
    2. Check price change over last 'momentum_minutes'.
    3. If positive -> LONG, negative -> SHORT.
    """
    
    def __init__(
        self,
        hour: int = 10,
        minute: int = 0,
        momentum_minutes: int = 15,
    ):
        self.hour = hour
        self.minute = minute
        self.momentum_minutes = momentum_minutes
        self._state = SimpleTimeState()
    
    @property
    def scanner_id(self) -> str:
        return f"simple_time_{self.hour:02d}{self.minute:02d}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        ny_time = t.astimezone(NY_TZ)
        
        # Check if it's the target time
        if ny_time.hour == self.hour and ny_time.minute == self.minute:
            # Check if we already traded today
            if self._state.last_trigger_date == ny_time.date():
                return ScanResult(scanner_id=self.scanner_id, triggered=False)
            
            # Helper to get price N minutes ago
            # features.x_price_1m is a numpy array of recent close prices
            # The last element is current price (-1).
            # We want price 'momentum_minutes' ago.
            prices = features.x_price_1m
            if hasattr(prices, 'flatten'):
                prices = prices.flatten()
            
            if prices is None or len(prices) < self.momentum_minutes:
                # Not enough data
                return ScanResult(scanner_id=self.scanner_id, triggered=False)
            
            current_price = float(features.current_price)
            past_price = float(prices[-(self.momentum_minutes + 1)]) # Approximate
            
            direction = "LONG" if current_price > past_price else "SHORT"
            
            self._state.last_trigger_date = ny_time.date()
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': direction,
                    'entry_price': current_price,
                    'past_price': past_price,
                    'momentum_minutes': self.momentum_minutes
                },
                score=1.0
            )
            
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/structure_break.py

```python
"""
Structure Break Scanner (15m, 2RR)
Triggers on structure break pattern:
1. Price makes new high/low
2. Then breaks the SECOND previous low/high (not the immediate one)
3. Wait for 15m candle close
4. Enter in direction of break
5. SL at candle extreme + 0.5 ATR
6. TP at 2RR
"""

import pandas as pd
import numpy as np
from typing import Optional, List
from dataclasses import dataclass, field
from datetime import time

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import POINT_VALUE, TICK_SIZE


@dataclass
class SwingPoint:
    """Represents a swing high or low."""
    price: float
    bar_idx: int
    time: pd.Timestamp
    is_high: bool  # True for swing high, False for swing low


@dataclass
class StructureBreakState:
    """Tracks swing structure and pattern detection."""
    swing_highs: List[SwingPoint] = field(default_factory=list)
    swing_lows: List[SwingPoint] = field(default_factory=list)
    last_trigger_bar: int = -1000
    recent_new_high: bool = False
    recent_new_low: bool = False
    new_high_bar: int = -1
    new_low_bar: int = -1


class StructureBreakScanner(Scanner):
    """
    Scanner that triggers on structure break pattern.
    
    Pattern (SHORT example):
    1. Price makes a new swing HIGH
    2. Then breaks the SECOND previous swing LOW (not the immediate one)
    3. Wait for 15m candle to close
    4. Enter SHORT at close
    5. SL at HIGH of trigger candle + 0.5 ATR
    6. TP = Entry - 2 * Risk
    
    Config:
        swing_lookback: Bars to look back for swing detection
        min_swing_bars: Minimum bars between swings
        cooldown_bars: Minimum bars between triggers
        max_risk_dollars: Maximum dollar risk per trade
        atr_padding: ATR multiple for SL padding (default 0.5)
    """
    
    def __init__(
        self,
        swing_lookback: int = 5,  # Bars left/right for swing detection
        min_swing_bars: int = 3,  # Min bars between swings
        cooldown_bars: int = 3,   # 3 bars = 45 min on 15m
        max_risk_dollars: float = 300.0,
        atr_padding: float = 0.5
    ):
        self.swing_lookback = swing_lookback
        self.min_swing_bars = min_swing_bars
        self.cooldown_bars = cooldown_bars
        self.max_risk_dollars = max_risk_dollars
        self.atr_padding = atr_padding
        self._state = StructureBreakState()
    
    @property
    def scanner_id(self) -> str:
        return "structure_break_2rr"
    
    def _find_swings(self, df_15m: pd.DataFrame, current_bar_idx: int) -> tuple:
        """
        Find swing highs and swing lows in the 15m data.
        A swing high is a bar whose high is higher than N bars before and after.
        Returns updated lists of swing highs and lows.
        """
        if df_15m is None or len(df_15m) < self.swing_lookback * 2 + 1:
            return self._state.swing_highs, self._state.swing_lows
        
        # Use recent data
        recent = df_15m.tail(100).copy()
        if len(recent) < self.swing_lookback * 2 + 1:
            return self._state.swing_highs, self._state.swing_lows
        
        highs = recent['high'].values
        lows = recent['low'].values
        times = recent['time'].values
        
        swing_highs = []
        swing_lows = []
        
        # Find swings (excluding the last swing_lookback bars - they're not confirmed)
        for i in range(self.swing_lookback, len(recent) - self.swing_lookback):
            # Check swing high
            is_swing_high = True
            for j in range(1, self.swing_lookback + 1):
                if highs[i] <= highs[i-j] or highs[i] <= highs[i+j]:
                    is_swing_high = False
                    break
            
            if is_swing_high:
                swing_highs.append(SwingPoint(
                    price=highs[i],
                    bar_idx=current_bar_idx - (len(recent) - 1 - i),
                    time=pd.Timestamp(times[i]),
                    is_high=True
                ))
            
            # Check swing low
            is_swing_low = True
            for j in range(1, self.swing_lookback + 1):
                if lows[i] >= lows[i-j] or lows[i] >= lows[i+j]:
                    is_swing_low = False
                    break
            
            if is_swing_low:
                swing_lows.append(SwingPoint(
                    price=lows[i],
                    bar_idx=current_bar_idx - (len(recent) - 1 - i),
                    time=pd.Timestamp(times[i]),
                    is_high=False
                ))
        
        # Keep only recent swings (last 10 of each)
        return swing_highs[-10:], swing_lows[-10:]
    
    def _calculate_position_size(self, entry: float, stop: float) -> tuple:
        """Calculate max contracts for given risk."""
        dist_points = abs(entry - stop)
        if dist_points < TICK_SIZE:
            return 0, 0.0
        
        risk_per_contract = dist_points * POINT_VALUE
        if risk_per_contract <= 0:
            return 0, 0.0
        
        contracts = int(self.max_risk_dollars // risk_per_contract)
        contracts = max(1, contracts)
        
        contract_risk = contracts * risk_per_contract
        if contract_risk > self.max_risk_dollars * 1.1:  # Allow 10% tolerance
            contracts = max(1, contracts - 1)
            contract_risk = contracts * risk_per_contract
        
        return contracts, contract_risk

    def scan(
        self,
        state: MarketState,
        features: FeatureBundle,
        df_15m: pd.DataFrame = None
    ) -> ScanResult:
        """Check for structure break pattern."""
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown check
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        if df_15m is None or df_15m.empty:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Update swing structure
        self._state.swing_highs, self._state.swing_lows = self._find_swings(df_15m, features.bar_idx)
        
        # Need at least 3 swing highs and 3 swing lows
        if len(self._state.swing_highs) < 3 or len(self._state.swing_lows) < 3:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Get current bar data
        current_bar = df_15m.iloc[-1]
        current_close = current_bar['close']
        current_high = current_bar['high']
        current_low = current_bar['low']
        
        atr = features.atr if features.atr > 0 else 5.0  # Default ATR
        
        # Check for SHORT setup:
        # 1. Recent new high (highest of recent swing highs)
        # 2. Current bar breaks the SECOND previous swing low
        
        sorted_highs = sorted(self._state.swing_highs, key=lambda x: x.bar_idx, reverse=True)
        sorted_lows = sorted(self._state.swing_lows, key=lambda x: x.bar_idx, reverse=True)
        
        # Check if we made a new high recently
        if len(sorted_highs) >= 2:
            most_recent_high = sorted_highs[0]
            prev_highs = sorted_highs[1:]
            is_new_high = all(most_recent_high.price > h.price for h in prev_highs[:3])
            
            if is_new_high and len(sorted_lows) >= 2:
                # Second previous low (skip the most recent one)
                second_prev_low = sorted_lows[1] if len(sorted_lows) > 1 else sorted_lows[0]
                
                # Check if current bar breaks the second previous low
                if current_close < second_prev_low.price:
                    # SHORT SIGNAL
                    entry_price = current_close
                    stop_price = current_high + (self.atr_padding * atr)
                    risk = stop_price - entry_price
                    
                    if risk > 0:
                        tp_price = entry_price - (2.0 * risk)
                        
                        contracts, actual_risk = self._calculate_position_size(entry_price, stop_price)
                        if contracts > 0:
                            self._state.last_trigger_bar = features.bar_idx
                            
                            return ScanResult(
                                scanner_id=self.scanner_id,
                                triggered=True,
                                context={
                                    'direction': 'SHORT',
                                    'entry_price': entry_price,
                                    'stop_price': stop_price,
                                    'tp_price': tp_price,
                                    'trigger_high': current_high,
                                    'trigger_low': current_low,
                                    'broken_level': second_prev_low.price,
                                    'new_high_price': most_recent_high.price,
                                    'risk_points': risk,
                                    'reward_points': 2.0 * risk,
                                    'contracts': contracts,
                                    'risk_dollars': actual_risk,
                                    'reward_dollars': actual_risk * 2.0,
                                    'rr_ratio': 2.0
                                },
                                score=1.0
                            )
        
        # Check for LONG setup:
        # 1. Recent new low (lowest of recent swing lows)
        # 2. Current bar breaks the SECOND previous swing high
        
        if len(sorted_lows) >= 2:
            most_recent_low = sorted_lows[0]
            prev_lows = sorted_lows[1:]
            is_new_low = all(most_recent_low.price < l.price for l in prev_lows[:3])
            
            if is_new_low and len(sorted_highs) >= 2:
                # Second previous high (skip the most recent one)
                second_prev_high = sorted_highs[1] if len(sorted_highs) > 1 else sorted_highs[0]
                
                # Check if current bar breaks the second previous high
                if current_close > second_prev_high.price:
                    # LONG SIGNAL
                    entry_price = current_close
                    stop_price = current_low - (self.atr_padding * atr)
                    risk = entry_price - stop_price
                    
                    if risk > 0:
                        tp_price = entry_price + (2.0 * risk)
                        
                        contracts, actual_risk = self._calculate_position_size(entry_price, stop_price)
                        if contracts > 0:
                            self._state.last_trigger_bar = features.bar_idx
                            
                            return ScanResult(
                                scanner_id=self.scanner_id,
                                triggered=True,
                                context={
                                    'direction': 'LONG',
                                    'entry_price': entry_price,
                                    'stop_price': stop_price,
                                    'tp_price': tp_price,
                                    'trigger_high': current_high,
                                    'trigger_low': current_low,
                                    'broken_level': second_prev_high.price,
                                    'new_low_price': most_recent_low.price,
                                    'risk_points': risk,
                                    'reward_points': 2.0 * risk,
                                    'contracts': contracts,
                                    'risk_dollars': actual_risk,
                                    'reward_dollars': actual_risk * 2.0,
                                    'rr_ratio': 2.0
                                },
                                score=1.0
                            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/swing_breakout.py

```python
"""
Swing Breakout Scanner
Triggers trades when price breaks above/below recent swing structure on 15m timeframe.
"""

import pandas as pd
import numpy as np
from typing import Optional, Dict, Any
from dataclasses import dataclass

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle


@dataclass
class SwingBreakoutState:
    """Tracks swing levels and cooldown."""
    last_trigger_bar: int = -1000
    last_swing_high: float = 0.0
    last_swing_low: float = 0.0


class SwingBreakoutScanner(Scanner):
    """
    Scanner that triggers on breakout of 15m swing structure.
    
    Logic:
    1. Compute swing high/low from last N 15m bars.
    2. Trigger LONG when current close breaks above swing high.
    3. Trigger SHORT when current close breaks below swing low.
    4. Stop placed at opposite swing level (structure-based).
    5. TP placed at next structure level (scanned).
    
    Config:
        lookback_bars: Number of 15m bars to look back for swing detection.
        min_atr_distance: Minimum breakout distance in ATR to avoid noise.
        cooldown_bars: Minimum 1m bars between triggers.
    """
    
    def __init__(
        self,
        lookback_bars: int = 10,
        min_atr_distance: float = 0.3,
        cooldown_bars: int = 15,
    ):
        self.lookback_bars = lookback_bars
        self.min_atr_distance = min_atr_distance
        self.cooldown_bars = cooldown_bars
        self._state = SwingBreakoutState()
        self._last_15m_bar_time: Optional[pd.Timestamp] = None
    
    @property
    def scanner_id(self) -> str:
        return f"swing_breakout_15m_{self.lookback_bars}"
    
    def _compute_swing_levels(self, df_15m: pd.DataFrame, current_time: pd.Timestamp) -> tuple:
        """
        Compute swing high and swing low from recent 15m bars.
        
        Returns:
            (swing_high, swing_low, swing_high_idx, swing_low_idx)
        """
        if df_15m is None or df_15m.empty:
            return (0.0, 0.0, -1, -1)
        
        # Get bars up to current time
        mask = df_15m['time'] <= current_time
        recent = df_15m.loc[mask].tail(self.lookback_bars + 1)  # +1 to exclude current bar
        
        if len(recent) < 3:
            return (0.0, 0.0, -1, -1)
        
        # Exclude current bar (last one) for swing computation
        lookback = recent.iloc[:-1] if len(recent) > 1 else recent
        
        swing_high = lookback['high'].max()
        swing_low = lookback['low'].min()
        
        swing_high_idx = lookback['high'].idxmax()
        swing_low_idx = lookback['low'].idxmin()
        
        return (swing_high, swing_low, swing_high_idx, swing_low_idx)
    
    def _find_next_structure_level(
        self, 
        df_15m: pd.DataFrame, 
        current_time: pd.Timestamp,
        direction: str,
        current_price: float
    ) -> float:
        """
        Find the next structure level for take profit.
        
        For LONG: Find next resistance (high) above current price.
        For SHORT: Find next support (low) below current price.
        """
        if df_15m is None or df_15m.empty:
            return 0.0
        
        # Look at more bars for TP target
        mask = df_15m['time'] <= current_time
        recent = df_15m.loc[mask].tail(self.lookback_bars * 2)
        
        if direction == "LONG":
            # Find highs above current price
            highs = recent['high'].values
            above_highs = [h for h in highs if h > current_price]
            if above_highs:
                # Return the nearest high above
                return min(above_highs)
            else:
                # No structure above, use highest high
                return max(highs) if len(highs) > 0 else current_price
        else:  # SHORT
            # Find lows below current price
            lows = recent['low'].values
            below_lows = [l for l in lows if l < current_price]
            if below_lows:
                # Return the nearest low below
                return max(below_lows)
            else:
                # No structure below, use lowest low
                return min(lows) if len(lows) > 0 else current_price
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle,
        df_15m: pd.DataFrame = None
    ) -> ScanResult:
        """
        Check for swing breakout.
        
        Note: df_15m must be passed in for swing computation.
        """
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown check
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Need 15m data for swing computation
        if df_15m is None or df_15m.empty:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Compute swing levels
        swing_high, swing_low, _, _ = self._compute_swing_levels(df_15m, t)
        
        if swing_high == 0 or swing_low == 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Update state
        self._state.last_swing_high = swing_high
        self._state.last_swing_low = swing_low
        
        current_price = features.current_price
        atr = features.atr if features.atr > 0 else 1.0
        min_breakout = self.min_atr_distance * atr
        
        # Check for breakout
        long_breakout = current_price > swing_high and (current_price - swing_high) >= min_breakout
        short_breakout = current_price < swing_low and (swing_low - current_price) >= min_breakout
        
        if long_breakout or short_breakout:
            direction = "LONG" if long_breakout else "SHORT"
            
            # Structure-based stop
            if direction == "LONG":
                stop_price = swing_low
                # Find TP at next structure above
                tp_price = self._find_next_structure_level(df_15m, t, direction, current_price)
                if tp_price <= current_price:
                    # Fallback: use 2x risk
                    risk = current_price - stop_price
                    tp_price = current_price + (2 * risk)
            else:  # SHORT
                stop_price = swing_high
                tp_price = self._find_next_structure_level(df_15m, t, direction, current_price)
                if tp_price >= current_price:
                    # Fallback: use 2x risk
                    risk = stop_price - current_price
                    tp_price = current_price - (2 * risk)
            
            self._state.last_trigger_bar = features.bar_idx
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': direction,
                    'swing_high': swing_high,
                    'swing_low': swing_low,
                    'breakout_price': current_price,
                    'stop_price': stop_price,
                    'tp_price': tp_price,
                    'entry_price': current_price,
                    'risk_points': abs(current_price - stop_price),
                    'reward_points': abs(tp_price - current_price),
                },
                score=1.0
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/volume_spike.py

```python
"""
Volume Spike Scanner
Triggers on unusual volume with price confirmation.
"""

import numpy as np
from typing import Optional
from dataclasses import dataclass, field

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import NY_TZ


@dataclass
class VolumeSpikeState:
    """Tracks volume history for spike detection."""
    volume_history: list = field(default_factory=list)
    last_trigger_bar: int = -1000


class VolumeSpikeScanner(Scanner):
    """
    Scanner that triggers on high-volume breakout bars.
    
    Logic:
    1. Calculate 20-bar volume average.
    2. Trigger when current volume > 2x average.
    3. Direction based on close vs open of spike bar.
    4. RTH only.
    
    Config:
        volume_multiple: How many times average for spike (default 2.0).
        lookback: Bars for volume average (default 20).
        cooldown_bars: Min bars between triggers (default 10).
    """
    
    def __init__(
        self,
        volume_multiple: float = 2.0,
        lookback: int = 20,
        cooldown_bars: int = 10,
    ):
        self.volume_multiple = volume_multiple
        self.lookback = lookback
        self.cooldown_bars = cooldown_bars
        self._state = VolumeSpikeState()
    
    @property
    def scanner_id(self) -> str:
        return f"volume_spike_{self.volume_multiple}x"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # RTH check
        ny_time = t.astimezone(NY_TZ)
        is_rth = (ny_time.hour == 9 and ny_time.minute >= 30) or (10 <= ny_time.hour < 16)
        if not is_rth:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Get current bar volume from market state
        current_volume = 0.0
        bar_open = features.current_price
        bar_close = features.current_price
        
        market_state = features.market_state
        if market_state is not None and market_state.ohlcv_1m is not None and len(market_state.ohlcv_1m) > 0:
            current_bar = market_state.ohlcv_1m[-1]
            if len(current_bar) >= 5:
                bar_open = float(current_bar[0])
                bar_close = float(current_bar[3])
                current_volume = float(current_bar[4])
        
        if current_volume <= 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Update volume history
        self._state.volume_history.append(current_volume)
        if len(self._state.volume_history) > self.lookback:
            self._state.volume_history = self._state.volume_history[-self.lookback:]
        
        # Need enough history
        if len(self._state.volume_history) < self.lookback:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Calculate average (excluding current bar)
        avg_volume = np.mean(self._state.volume_history[:-1])
        
        if avg_volume <= 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        volume_ratio = current_volume / avg_volume
        
        # Check for spike
        if volume_ratio >= self.volume_multiple:
            direction = "LONG" if bar_close > bar_open else "SHORT"
            bar_range = abs(bar_close - bar_open)
            
            self._state.last_trigger_bar = features.bar_idx
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': direction,
                    'volume_ratio': volume_ratio,
                    'current_volume': current_volume,
                    'avg_volume': avg_volume,
                    'spike_bar_range': bar_range,
                    'entry_price': features.current_price,
                },
                score=min(volume_ratio / self.volume_multiple, 2.0)  # Cap score at 2x threshold
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/library/vwap_bounce.py

```python
"""
VWAP Bounce Scanner
Triggers when price crosses and bounces off VWAP.
"""

import pandas as pd
from typing import Optional
from dataclasses import dataclass

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from src.config import NY_TZ


@dataclass
class VWAPBounceState:
    """Tracks VWAP interaction state."""
    was_above_vwap: Optional[bool] = None
    last_trigger_bar: int = -1000


class VWAPBounceScanner(Scanner):
    """
    Scanner that triggers on VWAP bounce setups.
    
    Logic:
    1. Track if price is above or below VWAP.
    2. LONG: Price dips below VWAP, then closes back above.
    3. SHORT: Price spikes above VWAP, then closes back below.
    4. RTH only (9:30 AM - 4:00 PM NY).
    
    Config:
        cooldown_bars: Minimum bars between triggers (default 15).
        min_penetration_atr: Min ATR penetration into VWAP zone (default 0.1).
    """
    
    def __init__(
        self,
        cooldown_bars: int = 15,
        min_penetration_atr: float = 0.1,
    ):
        self.cooldown_bars = cooldown_bars
        self.min_penetration_atr = min_penetration_atr
        self._state = VWAPBounceState()
    
    @property
    def scanner_id(self) -> str:
        return f"vwap_bounce_{self.cooldown_bars}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        t = features.timestamp
        if t is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # RTH check (9:30 AM - 4:00 PM NY)
        ny_time = t.astimezone(NY_TZ)
        if not (9 <= ny_time.hour < 16 or (ny_time.hour == 9 and ny_time.minute >= 30)):
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Need indicators for VWAP
        if features.indicators is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        vwap = features.indicators.vwap_session
        if vwap <= 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Cooldown check
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        price = features.current_price
        atr = features.atr if features.atr > 0 else 1.0
        
        currently_above = price > vwap
        
        # Check for bounce condition
        triggered = False
        direction = "neutral"
        
        if self._state.was_above_vwap is not None:
            # Was above, now below, but closing above = LONG bounce
            if self._state.was_above_vwap and currently_above:
                # Check if we dipped below during this bar
                # Using price proximity as proxy
                dist_to_vwap = abs(price - vwap) / atr
                if dist_to_vwap < self.min_penetration_atr * 2:
                    # Close to VWAP, potential bounce
                    pass
            
            # Transition: was below, now above = LONG
            if not self._state.was_above_vwap and currently_above:
                triggered = True
                direction = "LONG"
            
            # Transition: was above, now below = SHORT
            elif self._state.was_above_vwap and not currently_above:
                triggered = True
                direction = "SHORT"
        
        # Update state
        self._state.was_above_vwap = currently_above
        
        if triggered:
            self._state.last_trigger_bar = features.bar_idx
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    'direction': direction,
                    'vwap_level': vwap,
                    'entry_price': price,
                    'distance_atr': abs(price - vwap) / atr,
                },
                score=1.0
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

```

### src/policy/modular_scanner.py

```python
"""
Modular Scanner

Wraps Triggers to provide a standard Scanner interface.
"""

from typing import Dict, Any, Optional
import inspect

from src.policy.scanners import Scanner, ScanResult
from src.policy.triggers import Trigger, trigger_from_dict
from src.policy.triggers.base import TriggerDirection


class ModularScanner(Scanner):
    """
    Scanner that uses a modular Trigger to detect decision points.
    
    This bridges the high-level Scanner interface used by backtesters
    with the atomic Trigger components.
    """
    
    def __init__(self, trigger_config: Dict[str, Any], cooldown_bars: int = 20):
        self._trigger = trigger_from_dict(trigger_config)
        self._cooldown_bars = cooldown_bars
        self._last_trigger_idx = -1000
    
    @property
    def scanner_id(self) -> str:
        return f"modular_{self._trigger.trigger_id}"
    
    def scan(self, state, features, **kwargs) -> ScanResult:
        # Check cooldown
        current_idx = features.bar_idx if hasattr(features, 'bar_idx') else 0
        if current_idx - self._last_trigger_idx < self._cooldown_bars:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        # Check if trigger.check accepts kwargs
        sig = inspect.signature(self._trigger.check)
        accepts_kwargs = any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values())
        
        # Check trigger (pass kwargs only if trigger supports them)
        if accepts_kwargs:
            res = self._trigger.check(features, **kwargs)
        else:
            res = self._trigger.check(features)
        
        if res.triggered:
            self._last_trigger_idx = current_idx
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                context={
                    "direction": res.direction.value,
                    "trigger_id": res.trigger_id,
                    **res.context
                }
            )
        
        return ScanResult(scanner_id=self.scanner_id, triggered=False)

    def reset(self):
        self._trigger.reset()
        self._last_trigger_idx = -1000

```

### src/policy/oco_grid.py

```python
"""
OCO Grid
Standard variations of OCO configurations for multi-OCO testing.
Now includes stop type variations.
"""

from src.sim.oco_engine import OCOConfig
from src.sim.stop_calculator import StopType, StopConfig


# =============================================================================
# OCO Grid with SMART STOPS (based on actual levels, not just ATR offset)
# =============================================================================

# For Opening Range strategy: use OR levels as stops
OR_OCO_GRID = [
    # LONG: stop below OR low
    {
        'name': 'LONG_OR_1R',
        'direction': 'LONG',
        'stop_type': StopType.RANGE_LOW,
        'tp_multiple': 1.0,
        'atr_padding': 0.25,
    },
    {
        'name': 'LONG_OR_1.5R',
        'direction': 'LONG',
        'stop_type': StopType.RANGE_LOW,
        'tp_multiple': 1.5,
        'atr_padding': 0.25,
    },
    {
        'name': 'LONG_OR_2R',
        'direction': 'LONG',
        'stop_type': StopType.RANGE_LOW,
        'tp_multiple': 2.0,
        'atr_padding': 0.25,
    },
    
    # SHORT: stop above OR high
    {
        'name': 'SHORT_OR_1R',
        'direction': 'SHORT',
        'stop_type': StopType.RANGE_HIGH,
        'tp_multiple': 1.0,
        'atr_padding': 0.25,
    },
    {
        'name': 'SHORT_OR_1.5R',
        'direction': 'SHORT',
        'stop_type': StopType.RANGE_HIGH,
        'tp_multiple': 1.5,
        'atr_padding': 0.25,
    },
    {
        'name': 'SHORT_OR_2R',
        'direction': 'SHORT',
        'stop_type': StopType.RANGE_HIGH,
        'tp_multiple': 2.0,
        'atr_padding': 0.25,
    },
]


# Generic candle-based stops (for non-OR strategies)
CANDLE_OCO_GRID = [
    # LONG: stop below previous 5m candle low
    {
        'name': 'LONG_5M_LOW_1R',
        'direction': 'LONG',
        'stop_type': StopType.CANDLE_LOW,
        'timeframe': '5m',
        'tp_multiple': 1.0,
        'atr_padding': 0.25,
    },
    {
        'name': 'LONG_5M_LOW_2R',
        'direction': 'LONG',
        'stop_type': StopType.CANDLE_LOW,
        'timeframe': '5m',
        'tp_multiple': 2.0,
        'atr_padding': 0.25,
    },
    {
        'name': 'LONG_15M_LOW_1R',
        'direction': 'LONG',
        'stop_type': StopType.CANDLE_LOW,
        'timeframe': '15m',
        'tp_multiple': 1.0,
        'atr_padding': 0.25,
    },
    
    # SHORT: stop above previous 5m candle high
    {
        'name': 'SHORT_5M_HIGH_1R',
        'direction': 'SHORT',
        'stop_type': StopType.CANDLE_HIGH,
        'timeframe': '5m',
        'tp_multiple': 1.0,
        'atr_padding': 0.25,
    },
    {
        'name': 'SHORT_5M_HIGH_2R',
        'direction': 'SHORT',
        'stop_type': StopType.CANDLE_HIGH,
        'timeframe': '5m',
        'tp_multiple': 2.0,
        'atr_padding': 0.25,
    },
]


# =============================================================================
# LEGACY: Simple ATR-based OCO (for backwards compatibility)
# =============================================================================

OCO_GRID_10 = [
    # LONG variants
    OCOConfig(direction="LONG", stop_atr=1.0, tp_multiple=1.0, name="LONG_1ATR_1R"),
    OCOConfig(direction="LONG", stop_atr=1.0, tp_multiple=1.5, name="LONG_1ATR_1.5R"),
    OCOConfig(direction="LONG", stop_atr=1.0, tp_multiple=2.0, name="LONG_1ATR_2R"),
    OCOConfig(direction="LONG", stop_atr=0.5, tp_multiple=1.0, name="LONG_0.5ATR_1R"),
    OCOConfig(direction="LONG", stop_atr=1.5, tp_multiple=2.0, name="LONG_1.5ATR_2R"),
    
    # SHORT variants
    OCOConfig(direction="SHORT", stop_atr=1.0, tp_multiple=1.0, name="SHORT_1ATR_1R"),
    OCOConfig(direction="SHORT", stop_atr=1.0, tp_multiple=1.5, name="SHORT_1ATR_1.5R"),
    OCOConfig(direction="SHORT", stop_atr=1.0, tp_multiple=2.0, name="SHORT_1ATR_2R"),
    OCOConfig(direction="SHORT", stop_atr=0.5, tp_multiple=1.0, name="SHORT_0.5ATR_1R"),
    OCOConfig(direction="SHORT", stop_atr=1.5, tp_multiple=2.0, name="SHORT_1.5ATR_2R"),
]


def get_directional_oco_grid(direction: str):
    """Get legacy OCO grid filtered by direction."""
    return [oco for oco in OCO_GRID_10 if oco.direction == direction]


def get_or_oco_grid(direction: str):
    """Get Opening Range OCO grid filtered by direction."""
    return [cfg for cfg in OR_OCO_GRID if cfg['direction'] == direction]


def get_candle_oco_grid(direction: str):
    """Get candle-based OCO grid filtered by direction."""
    return [cfg for cfg in CANDLE_OCO_GRID if cfg['direction'] == direction]

```

### src/policy/scanner_registry_init.py

```python
"""
Scanner Registration
Wire existing scanners into the ScannerRegistry.
"""

from src.core.registries import ScannerRegistry
from src.policy.scanners import AlwaysScanner, IntervalScanner
from src.policy.modular_scanner import ModularScanner


# =============================================================================
# Register built-in scanners
# =============================================================================

@ScannerRegistry.register(
    scanner_id="always",
    name="Always Scanner",
    description="Triggers on every bar - useful for testing or fixed strategies",
    params_schema={}
)
class AlwaysScannerWrapper:
    """Wrapper to adapt AlwaysScanner to registry."""
    def __init__(self):
        self._scanner = AlwaysScanner()
    
    def scan(self, step_result):
        # Adapt to registry interface
        # In real use, would extract state and features from step_result
        from src.policy.scanners import ScanResult
        return ScanResult(
            scanner_id="always",
            triggered=True,
            score=1.0
        )


@ScannerRegistry.register(
    scanner_id="interval",
    name="Interval Scanner",
    description="Triggers every N bars",
    params_schema={
        "interval": {"type": "integer", "default": 5, "min": 1}
    }
)
class IntervalScannerWrapper:
    """Wrapper to adapt IntervalScanner to registry."""
    def __init__(self, interval: int = 5):
        self._scanner = IntervalScanner(interval=interval)
    
    def scan(self, step_result):
        from src.policy.scanners import ScanResult
        # Simplified - real implementation would extract features
        return ScanResult(
            scanner_id=f"interval_{self._scanner.interval}",
            triggered=False,  # Placeholder
            score=0.0
        )


@ScannerRegistry.register(
    scanner_id="modular",
    name="Modular Scanner",
    description="Scanner based on composable triggers (time, candle patterns, indicators)",
    params_schema={
        "trigger_config": {
            "type": "object",
            "description": "Trigger configuration dict",
            "required": True
        },
        "cooldown_bars": {
            "type": "integer",
            "default": 20,
            "min": 0
        }
    }
)
class ModularScannerWrapper:
    """Wrapper to adapt ModularScanner to registry."""
    def __init__(self, trigger_config: dict, cooldown_bars: int = 20):
        self._scanner = ModularScanner(
            trigger_config=trigger_config,
            cooldown_bars=cooldown_bars
        )
    
    def scan(self, step_result):
        from src.policy.scanners import ScanResult
        return ScanResult(
            scanner_id=self._scanner.scanner_id,
            triggered=False,  # Placeholder
            score=0.0
        )


# Auto-register on import
def register_all_scanners():
    """
    Register all available scanners.
    Call this at startup to populate the registry.
    """
    # The decorators above already registered them
    # This function just serves as a hook for explicit initialization
    pass

```

### src/policy/scanners.py

```python
"""
Scanners
Setup detection - determines when a decision point occurs.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional

from src.features.state import MarketState
from src.features.pipeline import FeatureBundle


@dataclass
class ScanResult:
    """Result from a scanner check."""
    scanner_id: str
    triggered: bool
    context: Dict[str, Any] = field(default_factory=dict)
    score: float = 0.0   # Confidence/strength of signal


class Scanner(ABC):
    """
    Base class for setup scanners.
    
    Scanners define WHEN a decision point occurs.
    They don't decide the action - just whether to evaluate.
    """
    
    @property
    @abstractmethod
    def scanner_id(self) -> str:
        """Unique identifier for this scanner."""
        pass
    
    @abstractmethod
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        """
        Check if current state triggers this scanner.
        
        Args:
            state: Current market state
            features: Computed features
            
        Returns:
            ScanResult with triggered flag and context
        """
        pass


class AlwaysScanner(Scanner):
    """
    Scanner that always triggers.
    Useful for testing or fixed-interval strategies.
    """
    
    @property
    def scanner_id(self) -> str:
        return "always"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=True,
            score=1.0
        )


class IntervalScanner(Scanner):
    """
    Scanner that triggers every N bars.
    """
    
    def __init__(self, interval: int = 5):
        self.interval = interval
        self._last_triggered = -interval
    
    @property
    def scanner_id(self) -> str:
        return f"interval_{self.interval}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        bar_idx = features.bar_idx
        
        if bar_idx - self._last_triggered >= self.interval:
            self._last_triggered = bar_idx
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=True,
                score=1.0
            )
        
        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=False
        )


class LevelProximityScanner(Scanner):
    """
    Scanner that triggers when price is near key levels.
    """
    
    def __init__(
        self,
        atr_threshold: float = 0.5,
        level_types: List[str] = None
    ):
        self.atr_threshold = atr_threshold
        self.level_types = level_types or ['1h', '4h', 'pdh', 'pdl']
    
    @property
    def scanner_id(self) -> str:
        return f"level_proximity_{self.atr_threshold}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        if features.levels is None or features.atr <= 0:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        levels = features.levels
        atr = features.atr
        price = features.current_price
        
        # Check distances to each level
        min_dist_atr = float('inf')
        nearest_level = None
        
        checks = [
            ('1h_high', levels.dist_1h_high),
            ('1h_low', levels.dist_1h_low),
            ('4h_high', levels.dist_4h_high),
            ('4h_low', levels.dist_4h_low),
            ('pdh', levels.dist_pdh),
            ('pdl', levels.dist_pdl),
        ]
        
        for name, dist in checks:
            dist_atr = abs(dist) / atr if atr > 0 else float('inf')
            if dist_atr < min_dist_atr:
                min_dist_atr = dist_atr
                nearest_level = name
        
        triggered = min_dist_atr <= self.atr_threshold
        
        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context={
                'nearest_level': nearest_level,
                'distance_atr': min_dist_atr,
            },
            score=max(0, 1 - min_dist_atr / self.atr_threshold) if triggered else 0
        )


class RSIExtremeScanner(Scanner):
    """
    Scanner that triggers at RSI extremes.
    """
    
    def __init__(
        self,
        oversold: float = 30.0,
        overbought: float = 70.0
    ):
        self.oversold = oversold
        self.overbought = overbought
    
    @property
    def scanner_id(self) -> str:
        return f"rsi_extreme_{int(self.oversold)}_{int(self.overbought)}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        if features.indicators is None:
            return ScanResult(scanner_id=self.scanner_id, triggered=False)
        
        rsi = features.indicators.rsi_5m_14
        
        oversold = rsi <= self.oversold
        overbought = rsi >= self.overbought
        triggered = oversold or overbought
        
        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context={
                'rsi': rsi,
                'condition': 'oversold' if oversold else 'overbought' if overbought else 'neutral',
            },
            score=1.0 if triggered else 0.0
        )


class ScriptScanner(Scanner):
    """
    Scanner that wraps standalone research scripts.
    
    This adapter allows successful research scripts (run_lunch_fade.py, run_rvap_scan.py, etc.)
    to be integrated into the main application pipeline without rewriting them as Scanner classes.
    
    The script must expose either:
    - get_signals(df, **kwargs) -> List[Dict]: Returns list of signal dictionaries
    - scan(df, idx, **kwargs) -> Optional[Dict]: Returns signal dict for specific bar or None
    
    Example:
        scanner = ScriptScanner(
            script_path="scripts/run_lunch_fade.py",
            script_kwargs={'stop_atr_mult': 0.5}
        )
    """
    
    def __init__(
        self,
        script_path: str,
        script_kwargs: Optional[Dict[str, Any]] = None
    ):
        """
        Args:
            script_path: Path to Python script (e.g., 'scripts/run_lunch_fade.py')
            script_kwargs: Optional kwargs to pass to the script's scan/get_signals function
        """
        self.script_path = script_path
        self.script_kwargs = script_kwargs or {}
        self._script_module = None
        self._scan_function = None
        self._load_script()
    
    def _load_script(self):
        """Dynamically import the script and find the scan/get_signals function."""
        import importlib.util
        from pathlib import Path
        
        script_file = Path(self.script_path)
        if not script_file.exists():
            raise FileNotFoundError(f"Script not found: {self.script_path}")
        
        # Load module from file path
        spec = importlib.util.spec_from_file_location("script_module", script_file)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load script: {self.script_path}")
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        self._script_module = module
        
        # Look for scan or get_signals function
        if hasattr(module, 'get_signals'):
            self._scan_function = module.get_signals
        elif hasattr(module, 'scan'):
            self._scan_function = module.scan
        else:
            raise AttributeError(
                f"Script {self.script_path} must expose either 'get_signals' or 'scan' function"
            )
    
    @property
    def scanner_id(self) -> str:
        script_name = Path(self.script_path).stem
        return f"script_{script_name}"
    
    def scan(
        self,
        state: MarketState,
        features: FeatureBundle
    ) -> ScanResult:
        """
        Call the script's scan function with current state.
        
        Note: This creates minimal bar data from MarketState.
        For batch scripts (get_signals), you may need to buffer state history.
        
        Limitation: Uses current_price for all OHLC values as MarketState
        doesn't track individual bar OHLC. Scripts requiring realistic 
        price movements should be converted to proper Scanner classes.
        """
        try:
            # Build a minimal DataFrame from state for compatibility
            # Most scripts expect DataFrame with OHLCV columns
            bar_data = {
                'time': [state.current_time],
                'open': [state.current_price],  # Simplified - same price for all
                'high': [state.current_price],
                'low': [state.current_price],
                'close': [state.current_price],
                'volume': [0],  # Volume not tracked in MarketState
            }
            
            import pandas as pd
            df = pd.DataFrame(bar_data)
            
            # Call script function
            # Check function capabilities by attempting to call it
            if self._scan_function.__name__ == 'get_signals':
                # Batch function - expects full DataFrame
                signals = self._scan_function(df, **self.script_kwargs)
                # Check if any signal for current bar
                triggered = len(signals) > 0
                context = signals[0] if signals else {}
            else:
                # Single bar scan function
                signal = self._scan_function(df, 0, **self.script_kwargs)
                triggered = signal is not None
                context = signal or {}
            
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=triggered,
                context=context,
                score=context.get('score', 1.0) if triggered else 0.0
            )
        except Exception as e:
            # Log error but don't crash - allows graceful degradation
            return ScanResult(
                scanner_id=self.scanner_id,
                triggered=False,
                context={'error': str(e)}
            )


def _discover_library_scanners() -> Dict[str, type]:
    """Helper to find all Scanner classes in the library."""
    import importlib
    import pkgutil
    import inspect
    from src.policy import library
    
    found = {}
    
    # Iterate over modules in the library package
    for loader, name, is_pkg in pkgutil.iter_modules(library.__path__):
        full_name = f"src.policy.library.{name}"
        module = importlib.import_module(full_name)
        
        # Find all classes that inherit from Scanner
        for cls_name, cls in inspect.getmembers(module, inspect.isclass):
            if issubclass(cls, Scanner) and cls is not Scanner:
                # Use a slugified name or something generic
                # For discovery, we'll try to use a 'base' name or the class name lowercased
                key = name.lower().replace('_', '')
                found[key] = cls
                
    return found


def get_scanner(scanner_id: str, **kwargs) -> Scanner:
    """Factory function to get scanner by ID."""
    scanners = {
        'always': AlwaysScanner,
        'interval': IntervalScanner,
        'level_proximity': LevelProximityScanner,
        'rsi_extreme': RSIExtremeScanner,
        'script': ScriptScanner,  # New: ScriptScanner adapter
    }
    
    # Add discovered library scanners
    scanners.update(_discover_library_scanners())
    
    # Extract base name
    # We support both 'rsi_extreme' and just 'rsi' if we wanted
    base = scanner_id.split('_')[0].lower().replace('_', '')
    
    if base in scanners:
        return scanners[base](**kwargs)
    
    # Also check full name matches in case of library scanners
    # e.g. middayreversal
    clean_id = scanner_id.replace('_', '').lower()
    for name, cls in scanners.items():
        if clean_id.startswith(name):
            return cls(**kwargs)
    
    raise ValueError(f"Unknown scanner: {scanner_id}. Available: {list(scanners.keys())}")

```

### src/policy/triggers/__init__.py

```python
"""
Trigger Components Package

Simple, atomic entry signals for agent-friendly strategy building.
"""

from .base import Trigger, TriggerResult, TriggerDirection
# Export classes for direct usage if needed
from .time_trigger import TimeTrigger
from .candle_patterns import CandlePatternTrigger, CandlePattern
from .indicator_triggers import EMACrossTrigger, RSIThresholdTrigger
from .structure_break import StructureBreakTrigger
from .fakeout import FakeoutTrigger
from .ema_rejection import EMA200RejectionTrigger
from .parametric import RejectionTrigger, ComparisonTrigger
from .sweep import SweepTrigger
from .or_false_break import ORFalseBreakTrigger
from .vwap_reclaim import VWAPReclaimTrigger
from .logic import AndTrigger, OrTrigger, NotTrigger

# Export factory
from .factory import trigger_from_dict, TRIGGER_REGISTRY, list_triggers

# Alias list_triggers if needed or just use keys
def list_triggers() -> list:
    return list(TRIGGER_REGISTRY.keys())

```

### src/policy/triggers/base.py

```python
"""
Trigger Components - Base Classes and Types

Triggers are the simplest atomic entry signals.
They answer: "Should we consider entering right now?"
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from enum import Enum


class TriggerDirection(Enum):
    """Direction bias from trigger."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"  # Trigger fires but no directional bias


@dataclass
class TriggerResult:
    """Result from checking a trigger."""
    trigger_id: str
    triggered: bool
    direction: TriggerDirection = TriggerDirection.NEUTRAL
    context: Dict[str, Any] = field(default_factory=dict)
    confidence: float = 1.0  # 0-1 confidence in signal


class Trigger(ABC):
    """
    Base class for atomic entry triggers.
    
    Triggers are simpler than Scanners:
    - No state management required (stateless preferred)
    - Single responsibility: "Does condition X hold right now?"
    - Composable: Multiple triggers can be ANDed/ORed together
    
    Agents can specify triggers via simple config dicts:
    {"type": "time", "hour": 10, "minute": 0}
    {"type": "ema_cross", "fast": 9, "slow": 21}
    """
    
    @property
    @abstractmethod
    def trigger_id(self) -> str:
        """Unique identifier for this trigger type."""
        pass
    
    @property
    def params(self) -> Dict[str, Any]:
        """Serializable parameters for this trigger instance."""
        return {}
    
    @abstractmethod
    def check(self, features: 'FeatureBundle') -> TriggerResult:
        """
        Check if trigger condition is met.
        
        Args:
            features: Current market features
            
        Returns:
            TriggerResult with triggered flag and context
        """
        pass
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize trigger to dict for agent use."""
        return {
            "type": self.trigger_id,
            **self.params
        }
    
    @classmethod
    def from_dict(cls, config: Dict[str, Any]) -> 'Trigger':
        """Factory method - implemented by registry."""
        raise NotImplementedError("Use trigger_from_dict() factory function")


# Import FeatureBundle for type hints (avoid circular import)
from src.features.pipeline import FeatureBundle

```

### src/policy/triggers/candle_patterns.py

```python
"""
Candle Pattern Trigger

Detects common candlestick patterns.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
import numpy as np

from .base import Trigger, TriggerResult, TriggerDirection


class CandlePattern(Enum):
    """Supported candle patterns."""
    HAMMER = "hammer"
    INVERTED_HAMMER = "inverted_hammer"
    BULLISH_ENGULFING = "bullish_engulfing"
    BEARISH_ENGULFING = "bearish_engulfing"
    DOJI = "doji"
    MORNING_STAR = "morning_star"  # Future
    EVENING_STAR = "evening_star"  # Future


def _body_size(o: float, c: float) -> float:
    """Absolute body size."""
    return abs(c - o)


def _upper_wick(o: float, h: float, c: float) -> float:
    """Upper wick length."""
    return h - max(o, c)


def _lower_wick(o: float, l: float, c: float) -> float:
    """Lower wick length."""
    return min(o, c) - l


def _total_range(h: float, l: float) -> float:
    """Total candle range."""
    return h - l


def _is_bullish(o: float, c: float) -> bool:
    """Is candle bullish (close > open)."""
    return c > o


class CandlePatternTrigger(Trigger):
    """
    Trigger that detects candlestick patterns.
    
    Agent config examples:
        {"type": "candle_pattern", "patterns": ["hammer"]}
        {"type": "candle_pattern", "patterns": ["bullish_engulfing", "bearish_engulfing"]}
        {"type": "candle_pattern", "patterns": ["doji"], "min_range_atr": 0.5}
    """
    
    def __init__(
        self,
        patterns: List[str],
        min_range_atr: float = 0.3,  # Min candle range as ATR multiple
        body_ratio_doji: float = 0.1,  # Max body/range for doji
        wick_ratio_hammer: float = 2.0,  # Min lower_wick/body for hammer
    ):
        self._patterns = [CandlePattern(p.lower()) for p in patterns]
        self._min_range_atr = min_range_atr
        self._body_ratio_doji = body_ratio_doji
        self._wick_ratio_hammer = wick_ratio_hammer
    
    @property
    def trigger_id(self) -> str:
        patterns_str = "_".join(p.value for p in self._patterns)
        return f"candle_{patterns_str}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "patterns": [p.value for p in self._patterns],
            "min_range_atr": self._min_range_atr,
        }
    
    def check(self, features) -> TriggerResult:
        """Check for candle patterns in recent price data."""
        atr = features.atr if features.atr > 0 else 1.0
        
        # Try to get OHLCV candles - prefer window.raw_ohlcv_1m
        candles = None
        
        # First try: window.raw_ohlcv_1m (actual OHLCV data)
        if hasattr(features, 'window') and features.window is not None:
            raw = getattr(features.window, 'raw_ohlcv_1m', None)
            if raw is not None and len(raw) >= 2:
                candles = raw[-3:] if len(raw) >= 3 else raw[-2:]
        
        # Fallback: x_price_1m if it looks like OHLCV data
        if candles is None:
            prices = features.x_price_1m
            if prices is not None and len(prices) >= 2:
                # Check if it's OHLCV format (list of lists with 5 elements)
                if isinstance(prices[0], (list, tuple)) and len(prices[0]) >= 4:
                    candles = prices[-3:] if len(prices) >= 3 else prices[-2:]
        
        if candles is None or len(candles) < 2:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Current candle is last one
        curr = candles[-1]  # [o, h, l, c, v]
        o, h, l, c = curr[0], curr[1], curr[2], curr[3]
        
        # Previous candle
        prev = candles[-2] if len(candles) >= 2 else None
        
        total_range = _total_range(h, l)
        body = _body_size(o, c)
        upper = _upper_wick(o, h, c)
        lower = _lower_wick(o, l, c)
        
        # Check minimum range
        if total_range < self._min_range_atr * atr:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Check each pattern
        for pattern in self._patterns:
            detected = False
            direction = TriggerDirection.NEUTRAL
            
            if pattern == CandlePattern.HAMMER:
                # Hammer: long lower wick, small body at top
                if body > 0 and lower >= self._wick_ratio_hammer * body and upper < body:
                    detected = True
                    direction = TriggerDirection.LONG
                    
            elif pattern == CandlePattern.INVERTED_HAMMER:
                # Inverted hammer: long upper wick, small body at bottom
                if body > 0 and upper >= self._wick_ratio_hammer * body and lower < body:
                    detected = True
                    direction = TriggerDirection.SHORT
                    
            elif pattern == CandlePattern.DOJI:
                # Doji: tiny body relative to range
                if total_range > 0 and body / total_range < self._body_ratio_doji:
                    detected = True
                    direction = TriggerDirection.NEUTRAL
                    
            elif pattern == CandlePattern.BULLISH_ENGULFING and prev is not None:
                # Bullish engulfing: current body engulfs previous, current is bullish
                po, pc = prev[0], prev[3]
                if _is_bullish(o, c) and not _is_bullish(po, pc):
                    if c > po and o < pc:  # Current body engulfs previous
                        detected = True
                        direction = TriggerDirection.LONG
                        
            elif pattern == CandlePattern.BEARISH_ENGULFING and prev is not None:
                # Bearish engulfing: current body engulfs previous, current is bearish
                po, pc = prev[0], prev[3]
                if not _is_bullish(o, c) and _is_bullish(po, pc):
                    if o > pc and c < po:  # Current body engulfs previous
                        detected = True
                        direction = TriggerDirection.SHORT
            
            if detected:
                return TriggerResult(
                    trigger_id=self.trigger_id,
                    triggered=True,
                    direction=direction,
                    context={
                        "pattern": pattern.value,
                        "body": body,
                        "upper_wick": upper,
                        "lower_wick": lower,
                        "range": total_range,
                    },
                    confidence=0.8
                )
        
        return TriggerResult(trigger_id=self.trigger_id, triggered=False)

```

### src/policy/triggers/ema_rejection.py

```python
"""
EMA 200 Rejection Trigger

Detects trending pullbacks that reject at the 200 EMA:
- Price in trend (20 EMA angled)
- Pullback touches/crosses 200 EMA
- Candle shows rejection (wick, close back on trend side)
- Near a key level for confluence

Agent config:
    {"type": "ema200_rejection"}
"""

from typing import Dict, Any
import pandas as pd
import numpy as np

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection
from src.features.pipeline import FeatureBundle


class EMA200RejectionTrigger(Trigger):
    """
    Trigger for 200 EMA rejection pullbacks in trending markets.
    
    Strategy Logic:
    1. 20 EMA must be angled (trending) - slope > threshold
    2. Price pulls back to touch/cross 200 EMA
    3. Candle shows rejection (closes back on trend side)
    4. Optionally: near a key level (PDH/PDL/HTF)
    
    For UPTREND (20 > 200, 20 EMA sloping up):
        - Price touches/dips below 200 EMA
        - Candle closes above 200 EMA  LONG
        
    For DOWNTREND (20 < 200, 20 EMA sloping down):
        - Price touches/spikes above 200 EMA
        - Candle closes below 200 EMA  SHORT
    """
    
    def __init__(
        self,
        ema_fast_period: int = 20,
        ema_slow_period: int = 200,
        slope_threshold: float = 0.02,  # Minimum slope for "trending"
        slope_lookback: int = 5,  # Bars to measure slope
        require_touch: bool = True,  # Must touch the 200 EMA
        level_proximity_atr: float = 0.0  # If > 0, require near level
    ):
        self._fast_period = ema_fast_period
        self._slow_period = ema_slow_period
        self._slope_threshold = slope_threshold
        self._slope_lookback = slope_lookback
        self._require_touch = require_touch
        self._level_proximity = level_proximity_atr
        
    @property
    def trigger_id(self) -> str:
        return f"ema{self._slow_period}_rejection"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "ema_fast": self._fast_period,
            "ema_slow": self._slow_period,
            "slope_threshold": self._slope_threshold,
            "slope_lookback": self._slope_lookback
        }
    
    def check(self, features: FeatureBundle, **kwargs) -> TriggerResult:
        """
        Check for EMA 200 rejection pattern.
        
        Requires features to have:
        - ema_20: 20 EMA value
        - ema_200: 200 EMA value
        - ema_20_prev: Previous 20 EMA values for slope (or we compute from history)
        - bar_high, bar_low, bar_close
        
        Or pass df_5m/df_15m in kwargs for computing EMAs.
        """
        # Get EMA values
        ema_fast = getattr(features, f'ema_{self._fast_period}', None)
        ema_slow = getattr(features, f'ema_{self._slow_period}', None)
        
        # Also check alternative attribute names
        if ema_fast is None:
            ema_fast = getattr(features, 'ema_20', None)
        if ema_slow is None:
            ema_slow = getattr(features, 'ema_200', None)
            
        if ema_fast is None or ema_slow is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "EMA values not available"}
            )
        
        # Get bar OHLC
        bar_high = getattr(features, 'bar_high', None)
        bar_low = getattr(features, 'bar_low', None)
        bar_close = getattr(features, 'bar_close', features.current_price)
        
        if bar_high is None or bar_low is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "Bar OHLC not available"}
            )
        
        # Get EMA slope (requires previous values)
        ema_fast_slope = getattr(features, 'ema_20_slope', 0)
        
        # Determine trend
        uptrend = ema_fast > ema_slow and ema_fast_slope > self._slope_threshold
        downtrend = ema_fast < ema_slow and ema_fast_slope < -self._slope_threshold
        
        if not uptrend and not downtrend:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={
                    "reason": "No clear trend",
                    "ema_fast": ema_fast,
                    "ema_slow": ema_slow,
                    "slope": ema_fast_slope
                }
            )
        
        # Check for rejection pattern
        triggered = False
        direction = TriggerDirection.NEUTRAL
        rejection_type = None
        
        if uptrend:
            # LONG setup: Bar touched/crossed below 200 EMA, closed above
            touched_200 = bar_low <= ema_slow
            closed_above = bar_close > ema_slow
            
            if touched_200 and closed_above:
                triggered = True
                direction = TriggerDirection.LONG
                rejection_type = "bullish_200_rejection"
                
        elif downtrend:
            # SHORT setup: Bar touched/crossed above 200 EMA, closed below
            touched_200 = bar_high >= ema_slow
            closed_below = bar_close < ema_slow
            
            if touched_200 and closed_below:
                triggered = True
                direction = TriggerDirection.SHORT
                rejection_type = "bearish_200_rejection"
        
        # Optional level proximity check
        if triggered and self._level_proximity > 0:
            atr = getattr(features, 'atr', 5.0)
            pdh = getattr(features, 'pdh', 0)
            pdl = getattr(features, 'pdl', 0)
            
            near_level = False
            if pdh > 0:
                dist_pdh = abs(bar_close - pdh) / atr
                if dist_pdh < self._level_proximity:
                    near_level = True
            if pdl > 0:
                dist_pdl = abs(bar_close - pdl) / atr
                if dist_pdl < self._level_proximity:
                    near_level = True
            
            if not near_level:
                triggered = False
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction,
            context={
                "ema_fast": float(ema_fast),
                "ema_slow": float(ema_slow),
                "ema_slope": float(ema_fast_slope),
                "bar_high": float(bar_high),
                "bar_low": float(bar_low),
                "bar_close": float(bar_close),
                "uptrend": uptrend,
                "downtrend": downtrend,
                "rejection_type": rejection_type
            }
        )
    
    def reset(self):
        """Reset state (stateless trigger)."""
        pass

```

### src/policy/triggers/factory.py

```python
"""
Trigger Factory
Separated from __init__ to avoid circular imports.
"""

from typing import Dict, Any, List

from .base import Trigger
from .time_trigger import TimeTrigger
from .candle_patterns import CandlePatternTrigger
from .indicator_triggers import EMACrossTrigger, RSIThresholdTrigger
from .structure_break import StructureBreakTrigger
from .fakeout import FakeoutTrigger
from .ema_rejection import EMA200RejectionTrigger
from .parametric import ComparisonTrigger # Removed RejectionTrigger to use new one
from .price_action_triggers import (
    RejectionTrigger, 
    PinBarTrigger, 
    EngulfingTrigger, 
    InsideBarTrigger, 
    DoubleTopBottomTrigger, 
    FlagPatternTrigger
)
from .sweep import SweepTrigger
from .or_false_break import ORFalseBreakTrigger
from .vwap_reclaim import VWAPReclaimTrigger


# Global Registry
TRIGGER_REGISTRY: Dict[str, Any] = {}


def register_triggers():
    """Populate registry. Call this once or ensure imports happen."""
    # Leaf triggers (no recursion)
    TRIGGER_REGISTRY["time"] = TimeTrigger
    TRIGGER_REGISTRY["candle_pattern"] = CandlePatternTrigger
    TRIGGER_REGISTRY["ema_cross"] = EMACrossTrigger
    TRIGGER_REGISTRY["rsi_threshold"] = RSIThresholdTrigger
    TRIGGER_REGISTRY["structure_break"] = StructureBreakTrigger
    TRIGGER_REGISTRY["fakeout"] = FakeoutTrigger
    TRIGGER_REGISTRY["ema200_rejection"] = EMA200RejectionTrigger
    
    # New Price Action Triggers
    TRIGGER_REGISTRY["rejection"] = RejectionTrigger
    TRIGGER_REGISTRY["pin_bar"] = PinBarTrigger
    TRIGGER_REGISTRY["engulfing"] = EngulfingTrigger
    TRIGGER_REGISTRY["inside_bar"] = InsideBarTrigger
    TRIGGER_REGISTRY["double_top_bottom"] = DoubleTopBottomTrigger
    TRIGGER_REGISTRY["flag_pattern"] = FlagPatternTrigger
    
    TRIGGER_REGISTRY["comparison"] = ComparisonTrigger
    TRIGGER_REGISTRY["sweep"] = SweepTrigger
    TRIGGER_REGISTRY["or_false_break"] = ORFalseBreakTrigger
    TRIGGER_REGISTRY["vwap_reclaim"] = VWAPReclaimTrigger
    
    # Logic triggers (recursive)
    from .logic import AndTrigger, OrTrigger, NotTrigger
    TRIGGER_REGISTRY["AND"] = AndTrigger
    TRIGGER_REGISTRY["OR"] = OrTrigger
    TRIGGER_REGISTRY["NOT"] = NotTrigger

def trigger_from_dict(config: dict) -> Trigger:
    """
    Factory function to create trigger from config dict.
    """
    config = config.copy()
    trigger_type = config.pop("type")
    
    if trigger_type not in TRIGGER_REGISTRY:
        # Try re-registering just in case import order messed it up
        register_triggers()
        if trigger_type not in TRIGGER_REGISTRY:
             raise ValueError(f"Unknown trigger type: {trigger_type}. Available: {list(TRIGGER_REGISTRY.keys())}")
    
    return TRIGGER_REGISTRY[trigger_type](**config)


def list_triggers() -> list:
    """List available trigger types for agent discovery."""
    return list(TRIGGER_REGISTRY.keys())


# Pre-populate registry after functions are defined
register_triggers()



```

### src/policy/triggers/fakeout.py

```python
"""
Fakeout Trigger

Detects level breaks that fail and close back through the level.
Examples: PDH fakeout (break above, close back below)  SHORT
         PDL fakeout (break below, close back above)  LONG
"""

from dataclasses import dataclass
from typing import Dict, Any, Optional
import pandas as pd

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection
from src.features.pipeline import FeatureBundle


@dataclass
class FakeoutConfig:
    """Configuration for fakeout detection."""
    level: str = "pdh"  # pdh, pdl
    buffer_points: float = 0.0  # Buffer for level break detection


class FakeoutTrigger(Trigger):
    """
    Trigger for level fakeout detection.
    
    A fakeout occurs when:
    1. Price breaks through a key level (PDH/PDL)
    2. But fails to hold and closes back through it
    
    For PDH fakeout (SHORT):
        - Bar high > PDH (broke above)
        - Bar close < PDH (closed back below)
        
    For PDL fakeout (LONG):
        - Bar low < PDL (broke below)
        - Bar close > PDL (closed back above)
    
    Agent config:
        {"type": "fakeout", "level": "pdh"}  # SHORT on PDH fakeout
        {"type": "fakeout", "level": "pdl"}  # LONG on PDL fakeout
    """
    
    def __init__(
        self,
        level: str = "pdh",
        buffer_points: float = 0.0
    ):
        self._level = level.lower()
        self._buffer = buffer_points
        
    @property
    def trigger_id(self) -> str:
        return f"fakeout_{self._level}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "level": self._level,
            "buffer_points": self._buffer
        }
    
    def check(self, features: FeatureBundle, **kwargs) -> TriggerResult:
        """
        Check for fakeout pattern.
        
        Requires features to have:
        - pdh, pdl: Previous day high/low levels
        - current_bar or last bar data with high, low, close
        """
        # Get the level value
        if self._level == "pdh":
            level_value = getattr(features, 'pdh', None)
            if level_value is None:
                level_value = features.levels.get('pdh') if hasattr(features, 'levels') else None
        elif self._level == "pdl":
            level_value = getattr(features, 'pdl', None)
            if level_value is None:
                level_value = features.levels.get('pdl') if hasattr(features, 'levels') else None
        else:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": f"Unknown level: {self._level}"}
            )
        
        if level_value is None or level_value == 0:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "Level not available"}
            )
        
        # Get current bar OHLC
        bar_high = features.bar_high if hasattr(features, 'bar_high') else None
        bar_low = features.bar_low if hasattr(features, 'bar_low') else None
        bar_close = features.bar_close if hasattr(features, 'bar_close') else features.current_price
        
        # Fallback to market_state if available
        if bar_high is None and hasattr(features, 'market_state'):
            bar_high = features.market_state.bar_high
            bar_low = features.market_state.bar_low
            bar_close = features.market_state.bar_close
        
        if bar_high is None or bar_low is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "Bar OHLC not available"}
            )
        
        # Check for fakeout pattern
        level_with_buffer = level_value + self._buffer if self._level == "pdh" else level_value - self._buffer
        
        if self._level == "pdh":
            # PDH Fakeout: broke above but closed below
            broke_level = bar_high > level_with_buffer
            closed_back = bar_close < level_value
            direction = TriggerDirection.SHORT
        else:
            # PDL Fakeout: broke below but closed above
            broke_level = bar_low < level_with_buffer
            closed_back = bar_close > level_value
            direction = TriggerDirection.LONG
        
        triggered = broke_level and closed_back
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction if triggered else TriggerDirection.NEUTRAL,
            context={
                "level": self._level,
                "level_value": level_value,
                "bar_high": bar_high,
                "bar_low": bar_low,
                "bar_close": bar_close,
                "broke_level": broke_level,
                "closed_back": closed_back,
                "fakeout_type": f"{self._level.upper()}_FAKEOUT" if triggered else None
            }
        )
    
    def reset(self):
        """Reset any state (stateless trigger, nothing to reset)."""
        pass

```

### src/policy/triggers/indicator_triggers.py

```python
"""
Indicator-Based Triggers

EMA crossovers, RSI thresholds, etc.
"""

from typing import Dict, Any, Optional
import numpy as np

from .base import Trigger, TriggerResult, TriggerDirection


class EMACrossTrigger(Trigger):
    """
    Trigger on EMA crossover.
    
    Agent config examples:
        {"type": "ema_cross", "fast": 9, "slow": 21}
        {"type": "ema_cross", "fast": 9, "slow": 21, "timeframe": "5m"}
    """
    
    def __init__(
        self,
        fast: int = 9,
        slow: int = 21,
        timeframe: str = "5m",
    ):
        self._fast = fast
        self._slow = slow
        self._timeframe = timeframe
        self._prev_fast_above = None  # Track previous state for crossover
    
    @property
    def trigger_id(self) -> str:
        return f"ema_cross_{self._fast}_{self._slow}_{self._timeframe}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "fast": self._fast,
            "slow": self._slow,
            "timeframe": self._timeframe,
        }
    
    def check(self, features) -> TriggerResult:
        """Check for EMA crossover."""
        # Get indicator values from features
        indicators = features.indicators
        if indicators is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Look up EMA values based on timeframe
        # Features store: ema_5m_20, ema_15m_20, ema_5m_200, etc.
        fast_key = f"ema_{self._timeframe}_{self._fast}"
        slow_key = f"ema_{self._timeframe}_{self._slow}"
        
        # Try to get values - fall back to common periods
        fast_ema = getattr(indicators, fast_key, None)
        slow_ema = getattr(indicators, slow_key, None)
        
        # Fallback: use available EMAs if exact match not found
        if fast_ema is None:
            fast_ema = getattr(indicators, 'ema_5m_20', 0)
        if slow_ema is None:
            slow_ema = getattr(indicators, 'ema_5m_200', 0)
        
        if fast_ema == 0 or slow_ema == 0:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        fast_above = fast_ema > slow_ema
        
        # Detect crossover
        if self._prev_fast_above is not None:
            if fast_above and not self._prev_fast_above:
                # Bullish cross: fast crossed above slow
                self._prev_fast_above = fast_above
                return TriggerResult(
                    trigger_id=self.trigger_id,
                    triggered=True,
                    direction=TriggerDirection.LONG,
                    context={
                        "cross_type": "bullish",
                        "fast_ema": fast_ema,
                        "slow_ema": slow_ema,
                    },
                    confidence=0.9
                )
            elif not fast_above and self._prev_fast_above:
                # Bearish cross: fast crossed below slow
                self._prev_fast_above = fast_above
                return TriggerResult(
                    trigger_id=self.trigger_id,
                    triggered=True,
                    direction=TriggerDirection.SHORT,
                    context={
                        "cross_type": "bearish",
                        "fast_ema": fast_ema,
                        "slow_ema": slow_ema,
                    },
                    confidence=0.9
                )
        
        self._prev_fast_above = fast_above
        return TriggerResult(trigger_id=self.trigger_id, triggered=False)
    
    def reset(self):
        """Reset state for new simulation."""
        self._prev_fast_above = None


class RSIThresholdTrigger(Trigger):
    """
    Trigger when RSI crosses threshold.
    
    Agent config examples:
        {"type": "rsi_threshold", "threshold": 30, "direction": "below"}
        {"type": "rsi_threshold", "threshold": 70, "direction": "above"}
        {"type": "rsi_threshold", "oversold": 30, "overbought": 70}  # Both
    """
    
    def __init__(
        self,
        threshold: Optional[float] = None,
        direction: Optional[str] = None,  # "above" or "below"
        oversold: float = 30.0,
        overbought: float = 70.0,
        timeframe: str = "5m",
    ):
        # Single threshold mode
        if threshold is not None and direction is not None:
            self._mode = "single"
            self._threshold = threshold
            self._direction = direction.lower()
            self._oversold = None
            self._overbought = None
        # Dual threshold mode
        else:
            self._mode = "dual"
            self._oversold = oversold
            self._overbought = overbought
            self._threshold = None
            self._direction = None
        
        self._timeframe = timeframe
        self._prev_rsi = None
    
    @property
    def trigger_id(self) -> str:
        if self._mode == "single":
            return f"rsi_{self._direction}_{int(self._threshold)}_{self._timeframe}"
        else:
            return f"rsi_{int(self._oversold)}_{int(self._overbought)}_{self._timeframe}"
    
    @property
    def params(self) -> Dict[str, Any]:
        if self._mode == "single":
            return {
                "threshold": self._threshold,
                "direction": self._direction,
                "timeframe": self._timeframe,
            }
        else:
            return {
                "oversold": self._oversold,
                "overbought": self._overbought,
                "timeframe": self._timeframe,
            }
    
    def check(self, features) -> TriggerResult:
        """Check RSI threshold conditions."""
        indicators = features.indicators
        if indicators is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Get RSI value
        rsi_key = f"rsi_{self._timeframe}_14"
        rsi = getattr(indicators, rsi_key, None)
        if rsi is None:
            rsi = getattr(indicators, 'rsi_5m_14', 50.0)
        
        triggered = False
        direction = TriggerDirection.NEUTRAL
        context = {"rsi": rsi}
        
        if self._mode == "single":
            if self._direction == "below" and rsi < self._threshold:
                if self._prev_rsi is None or self._prev_rsi >= self._threshold:
                    triggered = True
                    direction = TriggerDirection.LONG  # Oversold = bullish
                    context["condition"] = f"rsi_below_{self._threshold}"
            elif self._direction == "above" and rsi > self._threshold:
                if self._prev_rsi is None or self._prev_rsi <= self._threshold:
                    triggered = True
                    direction = TriggerDirection.SHORT  # Overbought = bearish
                    context["condition"] = f"rsi_above_{self._threshold}"
        else:
            # Dual threshold mode
            if rsi <= self._oversold:
                if self._prev_rsi is None or self._prev_rsi > self._oversold:
                    triggered = True
                    direction = TriggerDirection.LONG
                    context["condition"] = "oversold"
            elif rsi >= self._overbought:
                if self._prev_rsi is None or self._prev_rsi < self._overbought:
                    triggered = True
                    direction = TriggerDirection.SHORT
                    context["condition"] = "overbought"
        
        self._prev_rsi = rsi
        
        if triggered:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=True,
                direction=direction,
                context=context,
                confidence=0.85
            )
        
        return TriggerResult(trigger_id=self.trigger_id, triggered=False)
    
    def reset(self):
        """Reset state for new simulation."""
        self._prev_rsi = None

```

### src/policy/triggers/logic.py

```python
"""
Logic Triggers
Boolean logic for composing triggers: AND, OR, NOT.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection

from src.features.pipeline import FeatureBundle


class AndTrigger(Trigger):
    """
    Fires only if ALL child triggers fire.
    
    Direction logic:
    - If all children agree on direction (or are NEUTRAL), inherit that direction.
    - If children conflict (LONG vs SHORT), returns NEUTRAL (but still triggered).
    """
    
    def __init__(self, children: List[Dict[str, Any]]):
        from src.policy.triggers.factory import trigger_from_dict
        self.children_configs = children
        self._children: List[Trigger] = [trigger_from_dict(c) for c in children]
        
    @property
    def trigger_id(self) -> str:
        return "AND"
        
    @property
    def params(self) -> Dict[str, Any]:
        return {"children": self.children_configs}
        
    def check(self, features: FeatureBundle) -> TriggerResult:
        results = []
        for child in self._children:
            res = child.check(features)
            if not res.triggered:
                # Short circuit
                return TriggerResult(
                    trigger_id=self.trigger_id, 
                    triggered=False
                )
            results.append(res)
            
        # If we got here, all triggered
        
        # Determine direction
        directions = {r.direction for r in results if r.direction != TriggerDirection.NEUTRAL}
        
        final_dir = TriggerDirection.NEUTRAL
        if len(directions) == 1:
            final_dir = list(directions)[0]
        # If len > 1, conflict -> NEUTRAL (but triggered)
        
        # Merge context
        merged_context = {}
        for i, res in enumerate(results):
            # Prefix keys to avoid collisions? Or just merge?
            # Merging allows downstream to see "rsi": 30
            merged_context.update(res.context)
            
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=True,
            direction=final_dir,
            context=merged_context,
            confidence=min(r.confidence for r in results)  # Weakest link
        )


class OrTrigger(Trigger):
    """
    Fires if ANY child trigger fires.
    """
    
    def __init__(self, children: List[Dict[str, Any]]):
        from src.policy.triggers.factory import trigger_from_dict
        self.children_configs = children
        self._children: List[Trigger] = [trigger_from_dict(c) for c in children]
        
    @property
    def trigger_id(self) -> str:
        return "OR"
        
    @property
    def params(self) -> Dict[str, Any]:
        return {"children": self.children_configs}
        
    def check(self, features: FeatureBundle) -> TriggerResult:
        fired = []
        for child in self._children:
            res = child.check(features)
            if res.triggered:
                fired.append(res)
                
        if not fired:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
            
        # Use the most confident one, or the first one
        best_res = max(fired, key=lambda r: r.confidence)
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=True,
            direction=best_res.direction,
            context=best_res.context,
            confidence=best_res.confidence
        )


class NotTrigger(Trigger):
    """
    Inverts the triggered status of a child.
    
    Note: Direction is inverted if possible (LONG -> SHORT).
    """
    
    def __init__(self, child: Dict[str, Any]):
        from src.policy.triggers.factory import trigger_from_dict
        self.child_config = child
        self._child = trigger_from_dict(child)
        
    @property
    def trigger_id(self) -> str:
        return "NOT"
        
    @property
    def params(self) -> Dict[str, Any]:
        return {"child": self.child_config}
        
    def check(self, features: FeatureBundle) -> TriggerResult:
        res = self._child.check(features)
        
        # Invert triggered status
        triggered = not res.triggered
        
        if not triggered:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
            
        # Invert direction if valid
        direction = TriggerDirection.NEUTRAL
        if res.direction == TriggerDirection.LONG:
            direction = TriggerDirection.SHORT
        elif res.direction == TriggerDirection.SHORT:
            direction = TriggerDirection.LONG
            
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=True,
            direction=direction,
            context=res.context
        )

```

### src/policy/triggers/or_false_break.py

```python
"""
Opening Range False Break Trigger

Detects when OR is broken early but price comes back inside (trap).
Fade it back to the other side of the range.

Usage:
    trigger = ORFalseBreakTrigger(
        or_minutes=15,           # NY 9:30-9:45
        max_return_minutes=30,   # Must return within 30 mins
        session="NY"
    )
"""

from typing import Dict, Any, Optional
import pandas as pd

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection
from src.config import NY_TZ


class ORFalseBreakTrigger(Trigger):
    """
    Trigger for Opening Range false break pattern.
    
    Strategy: If we break the OR early and then come right back inside
    within the first hour, that feels like a trap  fade back to the 
    other side of the range.
    
    Logic:
    1. Establish OR during first N minutes (default 15 = 9:30-9:45 NY)
    2. Detect breakout (price closes outside OR)
    3. If price closes back inside OR within max_return_minutes  FADE
    4. Target: Other side of the range
    
    For break above OR_high then return inside:
         SHORT (fade back to OR_low)
        
    For break below OR_low then return inside:
         LONG (fade back to OR_high)
    """
    
    def __init__(
        self,
        or_minutes: int = 15,          # How long to establish OR
        max_return_minutes: int = 30,  # Max time for price to return
        session: str = "NY",           # NY, LONDON, or ASIA
        require_close_break: bool = True,  # Require close outside OR, not just wick
    ):
        self._or_minutes = or_minutes
        self._max_return = max_return_minutes
        self._session = session.upper()
        self._require_close = require_close_break
        
        # State tracking
        self._or_high = 0
        self._or_low = 0
        self._or_established = False
        self._break_direction: Optional[str] = None  # "ABOVE" or "BELOW"
        self._break_bar: int = 0
        self._break_time: Optional[pd.Timestamp] = None
        self._current_date: Optional[pd.Timestamp] = None
        self._or_bars = []
        self._triggered_today = False
        
    @property
    def trigger_id(self) -> str:
        return f"or_false_break_{self._or_minutes}m_{self._session.lower()}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "or_minutes": self._or_minutes,
            "max_return_minutes": self._max_return,
            "session": self._session
        }
    
    def _get_session_start(self) -> tuple[int, int]:
        """Get session start hour, minute based on session type."""
        if self._session == "NY":
            return (9, 30)
        elif self._session == "LONDON":
            return (3, 0)  # 3:00 AM NY time (8:00 London)
        elif self._session == "ASIA":
            return (19, 0)  # 7:00 PM NY time (previous day)
        else:
            return (9, 30)  # Default NY
    
    def _is_or_period(self, t: pd.Timestamp) -> bool:
        """Check if we're in the OR establishment period."""
        try:
            ny_time = t.astimezone(NY_TZ) if t.tzinfo else t.tz_localize(NY_TZ)
        except:
            return False
            
        hour, minute = ny_time.hour, ny_time.minute
        start_h, start_m = self._get_session_start()
        
        mins_since_midnight = hour * 60 + minute
        or_start = start_h * 60 + start_m
        or_end = or_start + self._or_minutes
        
        return or_start <= mins_since_midnight < or_end
    
    def _is_after_or(self, t: pd.Timestamp) -> bool:
        """Check if we're past the OR period."""
        try:
            ny_time = t.astimezone(NY_TZ) if t.tzinfo else t.tz_localize(NY_TZ)
        except:
            return False
            
        hour, minute = ny_time.hour, ny_time.minute
        start_h, start_m = self._get_session_start()
        
        mins_since_midnight = hour * 60 + minute
        or_end = start_h * 60 + start_m + self._or_minutes
        
        return mins_since_midnight >= or_end
    
    def _is_within_return_window(self, break_time: pd.Timestamp, current_time: pd.Timestamp) -> bool:
        """Check if we're still within max_return_minutes of the break."""
        if break_time is None:
            return False
        diff = (current_time - break_time).total_seconds() / 60
        return diff <= self._max_return
    
    def _is_new_day(self, t: pd.Timestamp) -> bool:
        """Check if this is a new trading day."""
        if self._current_date is None:
            return True
        try:
            ny_time = t.astimezone(NY_TZ) if t.tzinfo else t.tz_localize(NY_TZ)
            return ny_time.date() != self._current_date.date()
        except:
            return True
    
    def check(self, features, **kwargs) -> TriggerResult:
        """Check for OR false break pattern."""
        timestamp = getattr(features, 'timestamp', None)
        if timestamp is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Reset on new day
        if self._is_new_day(timestamp):
            try:
                self._current_date = timestamp.astimezone(NY_TZ) if timestamp.tzinfo else timestamp.tz_localize(NY_TZ)
            except:
                self._current_date = timestamp
            self._or_high = 0
            self._or_low = 0
            self._or_established = False
            self._break_direction = None
            self._break_time = None
            self._or_bars = []
            self._triggered_today = False
        
        bar_high = getattr(features, 'bar_high', 0)
        bar_low = getattr(features, 'bar_low', 0)
        bar_close = getattr(features, 'bar_close', 0) or getattr(features, 'current_price', 0)
        bar_idx = getattr(features, 'bar_idx', 0)
        
        # Collect bars during OR period
        if self._is_or_period(timestamp) and not self._or_established:
            self._or_bars.append({'high': bar_high, 'low': bar_low})
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Establish OR after period ends
        if self._is_after_or(timestamp) and not self._or_established and len(self._or_bars) > 0:
            self._or_high = max(b['high'] for b in self._or_bars)
            self._or_low = min(b['low'] for b in self._or_bars)
            self._or_established = True
        
        # Can't trigger if OR not established or already triggered today
        if not self._or_established or self._triggered_today:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # STATE MACHINE:
        # 1. Look for breakout
        # 2. If breakout detected, look for return inside
        
        triggered = False
        direction = TriggerDirection.NEUTRAL
        
        if self._break_direction is None:
            # Look for breakout
            if self._require_close:
                broke_above = bar_close > self._or_high
                broke_below = bar_close < self._or_low
            else:
                broke_above = bar_high > self._or_high
                broke_below = bar_low < self._or_low
            
            if broke_above:
                self._break_direction = "ABOVE"
                self._break_time = timestamp
                self._break_bar = bar_idx
            elif broke_below:
                self._break_direction = "BELOW"
                self._break_time = timestamp
                self._break_bar = bar_idx
                
        else:
            # Already have a breakout - look for return inside
            if not self._is_within_return_window(self._break_time, timestamp):
                # Timeout - reset break tracking
                self._break_direction = None
                self._break_time = None
            else:
                # Check if we're back inside the range
                inside_range = self._or_low <= bar_close <= self._or_high
                
                if inside_range:
                    # FALSE BREAK DETECTED - FADE IT
                    self._triggered_today = True
                    triggered = True
                    
                    if self._break_direction == "ABOVE":
                        # Broke above then came back = SHORT (fade to OR_low)
                        direction = TriggerDirection.SHORT
                    else:
                        # Broke below then came back = LONG (fade to OR_high)
                        direction = TriggerDirection.LONG
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction,
            context={
                "or_high": self._or_high,
                "or_low": self._or_low,
                "or_range": self._or_high - self._or_low,
                "break_direction": self._break_direction,
                "target": self._or_low if direction == TriggerDirection.SHORT else self._or_high,
                "session": self._session
            }
        )
    
    def reset(self):
        """Reset state for new run."""
        self._or_high = 0
        self._or_low = 0
        self._or_established = False
        self._break_direction = None
        self._break_time = None
        self._current_date = None
        self._or_bars = []
        self._triggered_today = False

```

### src/policy/triggers/parametric.py

```python
"""
Generic Rejection Trigger

Parametric trigger that detects rejections at any feature level.
The agent says: "rejection on ema_200"  RejectionTrigger(feature="ema_200")

Supported features:
- ema_X: EMA with period X (ema_20, ema_50, ema_200)
- pdh: Previous Day High
- pdl: Previous Day Low
- pdc: Previous Day Close
- vwap: VWAP
- level_X: Custom named level
"""

from typing import Dict, Any, Optional
import pandas as pd

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection


class RejectionTrigger(Trigger):
    """
    Generic trigger for price rejections at any feature level.
    
    A rejection occurs when price touches a feature but closes back
    on the opposite side, forming a rejection candle.
    
    For LONG rejection (bearish feature above price):
        - Bar high touches/crosses above feature
        - Bar closes below feature
        -  SHORT signal
        
    For SHORT covering rejection (bullish feature below price):
        - Bar low touches/crosses below feature
        - Bar closes above feature
        -  LONG signal
    
    Usage:
        # Rejection at 200 EMA
        trigger = RejectionTrigger(feature="ema_200")
        
        # Rejection at PDH (Previous Day High)
        trigger = RejectionTrigger(feature="pdh")
        
        # Long-only rejection (only take bullish rejections)
        trigger = RejectionTrigger(feature="ema_50", direction="long_only")
    """
    
    def __init__(
        self,
        feature: str,
        direction: str = "both",  # "both", "long_only", "short_only"
        require_trend: bool = False,  # If True, require trend alignment
        trend_feature: Optional[str] = None,  # e.g., "ema_20_slope"
        trend_threshold: float = 0.0,
    ):
        self._feature = feature
        self._direction = direction
        self._require_trend = require_trend
        self._trend_feature = trend_feature
        self._trend_threshold = trend_threshold
        
    @property
    def trigger_id(self) -> str:
        return f"rejection_{self._feature}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "feature": self._feature,
            "direction": self._direction,
            "require_trend": self._require_trend
        }
    
    def check(self, features, **kwargs) -> TriggerResult:
        """
        Check for rejection at the specified feature.
        
        The features object should have:
        - The feature value as an attribute (e.g., features.ema_200)
        - bar_high, bar_low, bar_close for the current candle
        """
        # Get feature value
        feature_value = getattr(features, self._feature, None)
        
        if feature_value is None or feature_value == 0:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": f"Feature '{self._feature}' not available"}
            )
        
        # Get bar OHLC
        bar_high = getattr(features, 'bar_high', None)
        bar_low = getattr(features, 'bar_low', None)
        bar_close = getattr(features, 'bar_close', None) or getattr(features, 'current_price', None)
        
        if bar_high is None or bar_low is None or bar_close is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "Bar OHLC not available"}
            )
        
        # Check for rejection patterns
        triggered = False
        direction = TriggerDirection.NEUTRAL
        rejection_type = None
        
        # Bearish rejection at feature above price  SHORT
        # Bar spiked up to touch feature but closed below it
        touched_above = bar_high >= feature_value
        closed_below = bar_close < feature_value
        
        if touched_above and closed_below and self._direction in ["both", "short_only"]:
            triggered = True
            direction = TriggerDirection.SHORT
            rejection_type = f"bearish_rejection_at_{self._feature}"
        
        # Bullish rejection at feature below price  LONG
        # Bar dipped down to touch feature but closed above it
        touched_below = bar_low <= feature_value
        closed_above = bar_close > feature_value
        
        if touched_below and closed_above and self._direction in ["both", "long_only"]:
            # Only trigger if not already triggered for SHORT (priority: first match)
            if not triggered:
                triggered = True
                direction = TriggerDirection.LONG
                rejection_type = f"bullish_rejection_at_{self._feature}"
        
        # Optional trend filter
        if triggered and self._require_trend:
            trend_value = getattr(features, self._trend_feature, 0) if self._trend_feature else 0
            
            # For LONG, want positive trend; for SHORT, want negative trend
            trend_aligned = (
                (direction == TriggerDirection.LONG and trend_value > self._trend_threshold) or
                (direction == TriggerDirection.SHORT and trend_value < -self._trend_threshold)
            )
            
            if not trend_aligned:
                triggered = False
                rejection_type = None
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction,
            context={
                "feature": self._feature,
                "feature_value": float(feature_value),
                "bar_high": float(bar_high),
                "bar_low": float(bar_low),
                "bar_close": float(bar_close),
                "touched_above": touched_above,
                "touched_below": touched_below,
                "rejection_type": rejection_type,
                "direction": direction.value if triggered else None
            }
        )
    
    def reset(self):
        """Reset state (stateless trigger)."""
        pass


class ComparisonTrigger(Trigger):
    """
    Generic trigger for comparing two features.
    
    Usage:
        # 20 EMA crosses above 200 EMA
        trigger = ComparisonTrigger(
            feature_a="ema_20",
            feature_b="ema_200", 
            condition="crosses_above"
        )
        
        # RSI below 30
        trigger = ComparisonTrigger(
            feature_a="rsi_14",
            feature_b=30,  # Can be a constant
            condition="below"
        )
        
        # Price above VWAP
        trigger = ComparisonTrigger(
            feature_a="current_price",
            feature_b="vwap",
            condition="above"
        )
    
    Conditions:
        - "above": A > B
        - "below": A < B
        - "crosses_above": A crossed above B (was below, now above)
        - "crosses_below": A crossed below B (was above, now below)
    """
    
    def __init__(
        self,
        feature_a: str,
        feature_b: str | float,  # Can be feature name or constant
        condition: str = "above",  # "above", "below", "crosses_above", "crosses_below"
        direction_on_true: str = "LONG",  # What direction when condition is true
    ):
        self._feature_a = feature_a
        self._feature_b = feature_b
        self._condition = condition
        self._direction_on_true = direction_on_true
        
        # For cross detection, track previous state
        self._prev_a_above_b: Optional[bool] = None
        
    @property
    def trigger_id(self) -> str:
        b_str = self._feature_b if isinstance(self._feature_b, str) else f"const_{self._feature_b}"
        return f"compare_{self._feature_a}_{self._condition}_{b_str}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "feature_a": self._feature_a,
            "feature_b": self._feature_b,
            "condition": self._condition,
            "direction_on_true": self._direction_on_true
        }
    
    def check(self, features, **kwargs) -> TriggerResult:
        """Check comparison between features."""
        # Get feature A value
        value_a = getattr(features, self._feature_a, None)
        if value_a is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": f"Feature '{self._feature_a}' not available"}
            )
        
        # Get feature B value (constant or feature)
        if isinstance(self._feature_b, (int, float)):
            value_b = self._feature_b
        else:
            value_b = getattr(features, self._feature_b, None)
            if value_b is None:
                return TriggerResult(
                    trigger_id=self.trigger_id,
                    triggered=False,
                    context={"error": f"Feature '{self._feature_b}' not available"}
                )
        
        # Compute current state
        a_above_b = value_a > value_b
        
        # Check condition
        triggered = False
        
        if self._condition == "above":
            triggered = a_above_b
        elif self._condition == "below":
            triggered = not a_above_b
        elif self._condition == "crosses_above":
            # Was below, now above
            if self._prev_a_above_b is not None:
                triggered = not self._prev_a_above_b and a_above_b
        elif self._condition == "crosses_below":
            # Was above, now below
            if self._prev_a_above_b is not None:
                triggered = self._prev_a_above_b and not a_above_b
        
        # Update previous state for cross detection
        self._prev_a_above_b = a_above_b
        
        # Determine direction
        if triggered:
            direction = TriggerDirection.LONG if self._direction_on_true == "LONG" else TriggerDirection.SHORT
        else:
            direction = TriggerDirection.NEUTRAL
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction,
            context={
                "feature_a": self._feature_a,
                "value_a": float(value_a),
                "feature_b": self._feature_b,
                "value_b": float(value_b) if isinstance(value_b, (int, float)) else value_b,
                "condition": self._condition,
                "a_above_b": a_above_b
            }
        )
    
    def reset(self):
        """Reset cross detection state."""
        self._prev_a_above_b = None

```

### src/policy/triggers/price_action_triggers.py

```python
"""
Price Action Triggers
Atomic triggers based on candlestick patterns and market structure.

Includes:
1. Rejection (Wick Rejection)
2. Pin Bar
3. Engulfing
4. Inside Bar
5. Double Top/Bottom
6. Flag Pattern
"""

from typing import Dict, Any, Optional
import numpy as np

from .base import Trigger, TriggerResult, TriggerDirection

class RejectionTrigger(Trigger):
    """
    Rejection Trigger (User Request).
    
    Logic:
    1. Identify range of previous M minutes (e.g., 30m).
    2. Check if current bar extended 1.5x of that range in one direction.
    3. Check if current bar CLOSED back inside or below/above the extension.
    
    Params:
        lookback (int): Number of bars for range calculation (e.g. 6 for 5m * 6 = 30m)
        extension_factor (float): 1.5
    """
    
    def __init__(self, lookback: int = 6, extension_factor: float = 1.5, timeframe: str = "5m"):
        self.lookback = lookback
        self.extension_factor = extension_factor
        self.timeframe = timeframe
        self.trigger_id_str = f"rejection_{timeframe}_{lookback}"

    @property
    def trigger_id(self) -> str:
        return self.trigger_id_str

    @property
    def params(self) -> Dict[str, Any]:
        return {
            "lookback": self.lookback,
            "extension_factor": self.extension_factor,
            "timeframe": self.timeframe
        }

    def check(self, features) -> TriggerResult:
        # Requires OHLC history. Assuming features.raw_candles exists or similar access.
        # Ideally, triggers should be stateless, but they need data access.
        # We assume 'features' object provides access to recent history.
        
        # NOTE: Using features.candles (deque or list of recent bars)
        candles = features.candles
        if len(candles) < self.lookback + 1:
             return TriggerResult(self.trigger_id, False)

        current_bar = candles[-1]
        history = list(candles)[-(self.lookback+1):-1] # Previous 'lookback' bars
        
        # Calculate recent range
        highs = [c.high for c in history]
        lows = [c.low for c in history]
        range_high = max(highs)
        range_low = min(lows)
        range_height = range_high - range_low
        
        if range_height == 0:
            return TriggerResult(self.trigger_id, False)

        # Bullish Rejection (Dip below range and close back up)
        # Extension target: Low - (Range * 0.5)? Or just price went below low?
        # User said: "1.5 of the previous 30m range" implies MOVE size.
        
        # Interpretation: 
        # Price moves DOWN by 1.5x the range height relative to range high? 
        # Or extended 50% beyond the range?
        # "1.5 in direction of move" -> Distance from High to Low of current move?
        
        # Common Rejection Logic:
        # Wick is long. 
        
        # Let's stick to a clear Rejection definition based on wicks relative to body.
        body = abs(current_bar.close - current_bar.open)
        wick_upper = current_bar.high - max(current_bar.open, current_bar.close)
        wick_lower = min(current_bar.open, current_bar.close) - current_bar.low
        total_len = current_bar.high - current_bar.low
        
        if total_len == 0:
             return TriggerResult(self.trigger_id, False)

        # Bullish Pin/Rejection: Long lower wick
        if wick_lower > (body * 2) and wick_lower > wick_upper:
             # Check if it swept a low?
             if current_bar.low < range_low:
                 return TriggerResult(self.trigger_id, True, TriggerDirection.LONG, {"type": "bullish_rejection", "support": range_low}, 0.8)

        # Bearish Pin/Rejection: Long upper wick
        if wick_upper > (body * 2) and wick_upper > wick_lower:
             if current_bar.high > range_high:
                 return TriggerResult(self.trigger_id, True, TriggerDirection.SHORT, {"type": "bearish_rejection", "resistance": range_high}, 0.8)

        return TriggerResult(self.trigger_id, False)


class PinBarTrigger(Trigger):
    """
    Classic Pin Bar Trigger.
    """
    def __init__(self, wick_ratio: float = 0.66):
        self.wick_ratio = wick_ratio
        
    @property
    def trigger_id(self) -> str: return "pin_bar"
    
    def check(self, features) -> TriggerResult:
        c = features.candles[-1]
        high, low, open_, close = c.high, c.low, c.open, c.close
        total_range = high - low
        if total_range == 0: return TriggerResult(self.trigger_id, False)
        
        upper_wick = high - max(open_, close)
        lower_wick = min(open_, close) - low
        
        # Bearish Pin
        if upper_wick / total_range >= self.wick_ratio:
            return TriggerResult(self.trigger_id, True, TriggerDirection.SHORT, {}, 0.7)
            
        # Bullish Pin
        if lower_wick / total_range >= self.wick_ratio:
            return TriggerResult(self.trigger_id, True, TriggerDirection.LONG, {}, 0.7)
            
        return TriggerResult(self.trigger_id, False)


class EngulfingTrigger(Trigger):
    """
    Engulfing Candle Trigger.
    """
    @property
    def trigger_id(self) -> str: return "engulfing"
    
    def check(self, features) -> TriggerResult:
        if len(features.candles) < 2: return TriggerResult(self.trigger_id, False)
        
        curr = features.candles[-1]
        prev = features.candles[-2]
        
        # Bullish Engulfing
        if (curr.close > curr.open) and (prev.close < prev.open): # Green after Red
            if (curr.close > prev.open) and (curr.open < prev.close): # Envelops body
                return TriggerResult(self.trigger_id, True, TriggerDirection.LONG, {}, 0.75)

        # Bearish Engulfing
        if (curr.close < curr.open) and (prev.close > prev.open): # Red after Green
            if (curr.close < prev.open) and (curr.open > prev.close):
                return TriggerResult(self.trigger_id, True, TriggerDirection.SHORT, {}, 0.75)
                
        return TriggerResult(self.trigger_id, False)


class InsideBarTrigger(Trigger):
    """
    Inside Bar Trigger.
    """
    @property
    def trigger_id(self) -> str: return "inside_bar"

    def check(self, features) -> TriggerResult:
        if len(features.candles) < 2: return TriggerResult(self.trigger_id, False)
        curr = features.candles[-1]
        prev = features.candles[-2]
        
        if (curr.high < prev.high) and (curr.low > prev.low):
            # Inside bar - usually implies potential breakout. 
            # Direction is neutral unless combined with trend.
            return TriggerResult(self.trigger_id, True, TriggerDirection.NEUTRAL, {}, 0.6)
            
        return TriggerResult(self.trigger_id, False)


class DoubleTopBottomTrigger(Trigger):
    """
    Simplified Double Top/Bottom detection.
    """
    @property
    def trigger_id(self) -> str: return "double_top_bottom"

    def check(self, features) -> TriggerResult:
        # Requires significant logic/zig-zag. Placeholder for now.
        return TriggerResult(self.trigger_id, False)


class FlagPatternTrigger(Trigger):
    """
    Bull/Bear Flag detection.
    """
    @property
    def trigger_id(self) -> str: return "flag_pattern"

    def check(self, features) -> TriggerResult:
         return TriggerResult(self.trigger_id, False)

```

### src/policy/triggers/structure_break.py

```python
"""
Structure Break Trigger
Triggers when price makes a new high/low then breaks the SECOND previous swing level.

Agent-configurable parameters:
- swing_lookback: Bars to confirm swing points (default 5)
- rr_ratio: Risk:Reward ratio for TP (default 2.0)
- atr_padding: ATR multiple for SL padding (default 0.5)
"""

import pandas as pd
import numpy as np
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection
from src.features.pipeline import FeatureBundle


@dataclass
class SwingPoint:
    """A detected swing high or low."""
    price: float
    bar_idx: int
    is_high: bool


@dataclass 
class StructureBreakState:
    """Persistent state for tracking swings."""
    swing_highs: List[SwingPoint] = field(default_factory=list)
    swing_lows: List[SwingPoint] = field(default_factory=list)
    last_trigger_bar: int = -1000


class StructureBreakTrigger(Trigger):
    """
    Triggers on structure break pattern:
    
    SHORT Setup:
    1. Price makes new swing HIGH
    2. Then breaks the SECOND previous swing LOW (not immediate)
    3. Enter at candle close
    
    LONG Setup:
    1. Price makes new swing LOW  
    2. Then breaks the SECOND previous swing HIGH
    3. Enter at candle close
    
    Agent Config Example:
    {"type": "structure_break", "swing_lookback": 5, "rr_ratio": 2.0, "atr_padding": 0.5}
    """
    
    def __init__(
        self,
        swing_lookback: int = 5,
        rr_ratio: float = 2.0,
        atr_padding: float = 0.5,
        cooldown_bars: int = 3
    ):
        self.swing_lookback = swing_lookback
        self.rr_ratio = rr_ratio
        self.atr_padding = atr_padding
        self.cooldown_bars = cooldown_bars
        self._state = StructureBreakState()
    
    @property
    def trigger_id(self) -> str:
        return "structure_break"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "swing_lookback": self.swing_lookback,
            "rr_ratio": self.rr_ratio,
            "atr_padding": self.atr_padding,
            "cooldown_bars": self.cooldown_bars
        }
    
    def _update_swings(self, df_15m: pd.DataFrame, current_bar_idx: int):
        """Detect swing highs and lows in 15m data."""
        if df_15m is None or len(df_15m) < self.swing_lookback * 2 + 1:
            return
        
        recent = df_15m.tail(60).copy()
        if len(recent) < self.swing_lookback * 2 + 1:
            return
        
        highs = recent['high'].values
        lows = recent['low'].values
        
        new_highs = []
        new_lows = []
        
        for i in range(self.swing_lookback, len(recent) - self.swing_lookback):
            # Swing high: higher than neighbors
            is_sh = all(highs[i] > highs[i-j] and highs[i] > highs[i+j] 
                       for j in range(1, self.swing_lookback + 1))
            if is_sh:
                new_highs.append(SwingPoint(
                    price=highs[i],
                    bar_idx=current_bar_idx - (len(recent) - 1 - i),
                    is_high=True
                ))
            
            # Swing low: lower than neighbors
            is_sl = all(lows[i] < lows[i-j] and lows[i] < lows[i+j]
                       for j in range(1, self.swing_lookback + 1))
            if is_sl:
                new_lows.append(SwingPoint(
                    price=lows[i],
                    bar_idx=current_bar_idx - (len(recent) - 1 - i),
                    is_high=False
                ))
        
        self._state.swing_highs = new_highs[-10:]
        self._state.swing_lows = new_lows[-10:]
    
    def check(self, features: FeatureBundle, df_15m: pd.DataFrame = None) -> TriggerResult:
        """Check for structure break pattern."""
        
        # Cooldown
        if features.bar_idx - self._state.last_trigger_bar < self.cooldown_bars:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        if df_15m is None or df_15m.empty:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        self._update_swings(df_15m, features.bar_idx)
        
        if len(self._state.swing_highs) < 2 or len(self._state.swing_lows) < 2:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        current_bar = df_15m.iloc[-1]
        close = current_bar['close']
        high = current_bar['high']
        low = current_bar['low']
        atr = features.atr if features.atr > 0 else 5.0
        
        sorted_highs = sorted(self._state.swing_highs, key=lambda x: x.bar_idx, reverse=True)
        sorted_lows = sorted(self._state.swing_lows, key=lambda x: x.bar_idx, reverse=True)
        
        # SHORT: Recent swing high exists + break second prev low
        # (removed is_new_high requirement - we just need a swing high followed by structure break)
        if len(sorted_highs) >= 1 and len(sorted_lows) >= 2:
            newest_high = sorted_highs[0]
            # Second previous low (skip the most recent)
            second_low = sorted_lows[1] if len(sorted_lows) > 1 else sorted_lows[0]
            
            # Only trigger if the swing high is more recent than the second low
            if newest_high.bar_idx > second_low.bar_idx and close < second_low.price:
                stop = high + (self.atr_padding * atr)
                risk = stop - close
                if risk > 0:
                    tp = close - (self.rr_ratio * risk)
                    self._state.last_trigger_bar = features.bar_idx
                    
                    return TriggerResult(
                        trigger_id=self.trigger_id,
                        triggered=True,
                        direction=TriggerDirection.SHORT,
                        context={
                            'entry_price': close,
                            'stop_price': stop,
                            'tp_price': tp,
                            'broken_level': second_low.price,
                            'new_extreme': newest_high.price,
                            'trigger_high': high,
                            'trigger_low': low,
                            'risk_points': risk,
                            'rr_ratio': self.rr_ratio
                        }
                    )
        
        # LONG: Recent swing low exists + break second prev high
        # (removed is_new_low requirement - we just need a swing low followed by structure break)
        if len(sorted_lows) >= 1 and len(sorted_highs) >= 2:
            newest_low = sorted_lows[0]
            # Second previous high (skip the most recent)
            second_high = sorted_highs[1] if len(sorted_highs) > 1 else sorted_highs[0]
            
            # Only trigger if the swing low is more recent than the second high
            if newest_low.bar_idx > second_high.bar_idx and close > second_high.price:
                stop = low - (self.atr_padding * atr)
                risk = close - stop
                if risk > 0:
                    tp = close + (self.rr_ratio * risk)
                    self._state.last_trigger_bar = features.bar_idx
                    
                    return TriggerResult(
                        trigger_id=self.trigger_id,
                        triggered=True,
                        direction=TriggerDirection.LONG,
                        context={
                            'entry_price': close,
                            'stop_price': stop,
                            'tp_price': tp,
                            'broken_level': second_high.price,
                            'new_extreme': newest_low.price,
                            'trigger_high': high,
                            'trigger_low': low,
                            'risk_points': risk,
                            'rr_ratio': self.rr_ratio
                        }
                    )
        
        return TriggerResult(trigger_id=self.trigger_id, triggered=False)

```

### src/policy/triggers/sweep.py

```python
"""
Sweep/Stop Run Trigger

Detects stop runs where price barely takes out a level then immediately reverses.
Perfect for fading PDH/PDL sweeps (liquidity grabs).

Usage:
    # Fade PDH sweep (short after barely taking out PDH)
    trigger = SweepTrigger(level="pdh", sweep_type="fade")
    
    # Fade PDL sweep (long after barely taking out PDL)
    trigger = SweepTrigger(level="pdl", sweep_type="fade")
"""

from typing import Dict, Any
import pandas as pd

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection


class SweepTrigger(Trigger):
    """
    Trigger for stop run/sweep patterns.
    
    A sweep occurs when:
    1. Price barely takes out a key level (PDH, PDL, prior swing)
    2. The move is small (within max_sweep_pts of level)
    3. Price closes back on the opposite side of the level
    
    For PDH sweep (SHORT fade):
        - Bar high > PDH (swept above)
        - Sweep distance = bar_high - PDH < max_sweep
        - Bar close < PDH (closed back below)
        -  SHORT signal
        
    For PDL sweep (LONG fade):
        - Bar low < PDL (swept below)
        - Sweep distance = PDL - bar_low < max_sweep
        - Bar close > PDL (closed back above)
        -  LONG signal
    """
    
    def __init__(
        self,
        level: str = "pdh",
        sweep_type: str = "fade",  # "fade" to trade against sweep
        max_sweep_pts: float = 5.0,  # Max points beyond level to count as "barely"
        min_sweep_pts: float = 0.25,  # Min points beyond level (must actually sweep)
    ):
        self._level = level.lower()
        self._sweep_type = sweep_type
        self._max_sweep = max_sweep_pts
        self._min_sweep = min_sweep_pts
        
    @property
    def trigger_id(self) -> str:
        return f"sweep_{self._level}_{self._sweep_type}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "level": self._level,
            "sweep_type": self._sweep_type,
            "max_sweep_pts": self._max_sweep,
            "min_sweep_pts": self._min_sweep
        }
    
    def check(self, features, **kwargs) -> TriggerResult:
        """
        Check for sweep pattern at the specified level.
        
        Requires features to have:
        - The level value (e.g., features.pdh, features.pdl)
        - bar_high, bar_low, bar_close
        """
        # Get level value
        level_value = getattr(features, self._level, None)
        
        if level_value is None or level_value == 0:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": f"Level '{self._level}' not available"}
            )
        
        # Get bar OHLC
        bar_high = getattr(features, 'bar_high', None)
        bar_low = getattr(features, 'bar_low', None)
        bar_close = getattr(features, 'bar_close', None) or getattr(features, 'current_price', None)
        
        if bar_high is None or bar_low is None or bar_close is None:
            return TriggerResult(
                trigger_id=self.trigger_id,
                triggered=False,
                context={"error": "Bar OHLC not available"}
            )
        
        triggered = False
        direction = TriggerDirection.NEUTRAL
        sweep_type_detected = None
        sweep_distance = 0
        
        # Check for PDH/high level sweep (SHORT fade)
        if self._level in ["pdh", "high", "swing_high"]:
            swept = bar_high > level_value  # Took out the high
            sweep_distance = bar_high - level_value
            barely_swept = self._min_sweep <= sweep_distance <= self._max_sweep
            closed_back = bar_close < level_value  # Closed back below
            
            if swept and barely_swept and closed_back:
                triggered = True
                direction = TriggerDirection.SHORT if self._sweep_type == "fade" else TriggerDirection.LONG
                sweep_type_detected = f"{self._level}_sweep_fade"
                
        # Check for PDL/low level sweep (LONG fade)
        elif self._level in ["pdl", "low", "swing_low"]:
            swept = bar_low < level_value  # Took out the low
            sweep_distance = level_value - bar_low
            barely_swept = self._min_sweep <= sweep_distance <= self._max_sweep
            closed_back = bar_close > level_value  # Closed back above
            
            if swept and barely_swept and closed_back:
                triggered = True
                direction = TriggerDirection.LONG if self._sweep_type == "fade" else TriggerDirection.SHORT
                sweep_type_detected = f"{self._level}_sweep_fade"
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=triggered,
            direction=direction,
            context={
                "level": self._level,
                "level_value": float(level_value),
                "bar_high": float(bar_high),
                "bar_low": float(bar_low),
                "bar_close": float(bar_close),
                "sweep_distance": float(sweep_distance),
                "sweep_type": sweep_type_detected,
                "direction": direction.value if triggered else None
            }
        )
    
    def reset(self):
        """Reset state (stateless trigger)."""
        pass

```

### src/policy/triggers/time_trigger.py

```python
"""
Time Trigger

Fires at specific times of day. Simple and predictable for testing.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass
import pandas as pd
from zoneinfo import ZoneInfo

from .base import Trigger, TriggerResult, TriggerDirection
from src.config import NY_TZ


class TimeTrigger(Trigger):
    """
    Trigger that fires at specific time(s) daily.
    
    Agent config examples:
        {"type": "time", "hour": 10, "minute": 0}
        {"type": "time", "hour": 10, "minute": 0, "direction": "LONG"}
        {"type": "time", "hours": [10, 14], "minute": 0}  # Multiple times
    """
    
    def __init__(
        self,
        hour: Optional[int] = None,
        minute: int = 0,
        hours: Optional[List[int]] = None,
        time: Optional[str] = None,  # Accept "HH:MM" format from agent
        direction: str = "NEUTRAL",
        timezone: str = "America/New_York",
    ):
        # Support 'time' parameter as string (e.g., "10:00", "11:30")
        if time is not None and hour is None:
            parts = str(time).split(":")
            hour = int(parts[0])
            if len(parts) > 1:
                minute = int(parts[1])
        
        # Support single hour or multiple hours
        if hours is not None:
            self._hours = hours
        elif hour is not None:
            self._hours = [hour]
        else:
            raise ValueError("Must specify 'hour', 'hours', or 'time'")
        
        self._minute = minute
        self._direction = TriggerDirection[direction.upper()]
        self._tz = ZoneInfo(timezone)
        
        # Track last trigger date to avoid double-firing
        self._last_trigger_dates: Dict[int, Any] = {}
    
    @property
    def trigger_id(self) -> str:
        hours_str = "_".join(str(h) for h in self._hours)
        return f"time_{hours_str}_{self._minute:02d}"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "hours": self._hours,
            "minute": self._minute,
            "direction": self._direction.value,
        }
    
    def check(self, features) -> TriggerResult:
        """Check if current time matches target time."""
        t = features.timestamp
        if t is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Convert to target timezone
        local_time = t.astimezone(self._tz)
        current_hour = local_time.hour
        current_minute = local_time.minute
        current_date = local_time.date()
        
        # Check if current time matches any target hour
        for target_hour in self._hours:
            if current_hour == target_hour and current_minute == self._minute:
                # Check if we already triggered for this hour today
                if self._last_trigger_dates.get(target_hour) == current_date:
                    continue  # Already triggered
                
                # Mark as triggered
                self._last_trigger_dates[target_hour] = current_date
                
                return TriggerResult(
                    trigger_id=self.trigger_id,
                    triggered=True,
                    direction=self._direction,
                    context={
                        "hour": target_hour,
                        "minute": self._minute,
                        "local_time": local_time.strftime("%H:%M"),
                    },
                    confidence=1.0
                )
        
        return TriggerResult(trigger_id=self.trigger_id, triggered=False)
    
    def reset(self):
        """Reset trigger state (for new simulation runs)."""
        self._last_trigger_dates.clear()

```

### src/policy/triggers/vwap_reclaim.py

```python
"""
VWAP Reclaim Trigger

Detects when price reclaims VWAP after being below it and holds.
Perfect for power hour reversals.

Usage:
    trigger = VWAPReclaimTrigger(
        min_time="14:30",        # After 2:30 PM ET
        hold_minutes=10,         # Hold above VWAP for 10 mins
        min_below_minutes=30     # Must have been below for at least 30 mins
    )
"""

from typing import Dict, Any, Optional
import pandas as pd

from src.policy.triggers.base import Trigger, TriggerResult, TriggerDirection
from src.config import NY_TZ


class VWAPReclaimTrigger(Trigger):
    """
    Trigger for VWAP reclaim pattern.
    
    Strategy: After 2:30 PM, if price was under VWAP all morning,
    then reclaims and holds for 10 minutes  long to PDH/day high.
    
    Logic:
    1. Only trigger after min_time (default 14:30 = 2:30 PM ET)
    2. Track if price has been below VWAP for min_below_minutes
    3. Detect when close > VWAP (reclaim)
    4. Wait for hold_minutes consecutive closes above VWAP
    5. Trigger LONG when hold confirmed
    
    Required features: vwap_session (must be in FeatureBundle)
    """
    
    def __init__(
        self,
        min_time: str = "14:30",      # Earliest trigger time (HH:MM in ET)
        hold_minutes: int = 10,        # Hold above VWAP requirement
        min_below_minutes: int = 30,   # Must have been below for this long
        direction: str = "LONG"        # Usually LONG on reclaim
    ):
        self._min_time = min_time
        self._hold_minutes = hold_minutes
        self._min_below = min_below_minutes
        self._direction = direction
        
        # State tracking
        self._current_date: Optional[pd.Timestamp] = None
        self._below_vwap_since: Optional[pd.Timestamp] = None
        self._reclaim_time: Optional[pd.Timestamp] = None
        self._consecutive_above: int = 0
        self._triggered_today = False
        
    @property
    def trigger_id(self) -> str:
        return f"vwap_reclaim_{self._min_time.replace(':', '')}_{self._hold_minutes}m"
    
    @property
    def params(self) -> Dict[str, Any]:
        return {
            "min_time": self._min_time,
            "hold_minutes": self._hold_minutes,
            "min_below_minutes": self._min_below,
            "direction": self._direction
        }
    
    def _is_new_day(self, t: pd.Timestamp) -> bool:
        if self._current_date is None:
            return True
        try:
            ny_time = t.astimezone(NY_TZ) if t.tzinfo else t.tz_localize(NY_TZ)
            return ny_time.date() != self._current_date.date()
        except:
            return True
    
    def _is_after_min_time(self, t: pd.Timestamp) -> bool:
        try:
            ny_time = t.astimezone(NY_TZ) if t.tzinfo else t.tz_localize(NY_TZ)
            hour, minute = map(int, self._min_time.split(':'))
            current_mins = ny_time.hour * 60 + ny_time.minute
            min_mins = hour * 60 + minute
            return current_mins >= min_mins
        except:
            return False
    
    def check(self, features, **kwargs) -> TriggerResult:
        """Check for VWAP reclaim pattern."""
        timestamp = getattr(features, 'timestamp', None)
        if timestamp is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Reset on new day
        if self._is_new_day(timestamp):
            try:
                self._current_date = timestamp.astimezone(NY_TZ) if timestamp.tzinfo else timestamp.tz_localize(NY_TZ)
            except:
                self._current_date = timestamp
            self._below_vwap_since = None
            self._reclaim_time = None
            self._consecutive_above = 0
            self._triggered_today = False
        
        # Get VWAP - check multiple possible attribute names
        vwap = getattr(features, 'vwap_session', None) or getattr(features, 'vwap', None)
        if vwap is None or vwap <= 0:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        current_price = getattr(features, 'current_price', 0) or getattr(features, 'bar_close', 0)
        if current_price <= 0:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Track below VWAP period
        if current_price < vwap:
            if self._below_vwap_since is None:
                self._below_vwap_since = timestamp
            self._consecutive_above = 0
            self._reclaim_time = None
        else:
            # Price is above VWAP
            if self._reclaim_time is None and self._below_vwap_since is not None:
                # Just reclaimed!
                self._reclaim_time = timestamp
            self._consecutive_above += 1
        
        # Check trigger conditions
        if self._triggered_today:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        if not self._is_after_min_time(timestamp):
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        if self._below_vwap_since is None:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Check minimum below time
        below_duration = (self._reclaim_time or timestamp) - self._below_vwap_since
        below_minutes = below_duration.total_seconds() / 60
        if below_minutes < self._min_below:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # Check hold requirement
        if self._consecutive_above < self._hold_minutes:
            return TriggerResult(trigger_id=self.trigger_id, triggered=False)
        
        # TRIGGER!
        self._triggered_today = True
        
        direction = TriggerDirection.LONG if self._direction == "LONG" else TriggerDirection.SHORT
        
        return TriggerResult(
            trigger_id=self.trigger_id,
            triggered=True,
            direction=direction,
            context={
                "vwap": vwap,
                "current_price": current_price,
                "below_minutes": below_minutes,
                "hold_minutes": self._consecutive_above,
                "reclaim_time": str(self._reclaim_time) if self._reclaim_time else None
            }
        )
    
    def reset(self):
        self._current_date = None
        self._below_vwap_since = None
        self._reclaim_time = None
        self._consecutive_above = 0
        self._triggered_today = False

```

### src/server/__init__.py

```python
"""
Server Package
FastAPI backend for mlang2 frontend.
"""

```

### src/server/db_routes.py

```python
"""
Experiments DB Routes

API endpoints for interacting with the ExperimentDB.
"""

from typing import Dict, Any, List, Optional
from fastapi import APIRouter, HTTPException, Query, Body
from pydantic import BaseModel
import shutil
import json

from src.storage import ExperimentDB
from src.config import RESULTS_DIR

router = APIRouter(prefix="/experiments", tags=["experiments"])

class ExperimentResponse(BaseModel):
    run_id: str
    created_at: str
    strategy: str
    config: Dict[str, Any]
    total_trades: int
    wins: int
    losses: int
    win_rate: float
    total_pnl: float
    avg_pnl_per_trade: float
    sharpe: Optional[float] = None
    max_drawdown: Optional[float] = None
    profit_factor: Optional[float] = None

    # Computed fields
    has_viz: bool = False

@router.get("", response_model=Dict[str, Any])
async def list_experiments(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    sort_by: str = Query("created_at", pattern="^(created_at|win_rate|total_pnl|total_trades)$"),
    sort_desc: bool = Query(True),
    strategy: Optional[str] = Query(None)
):
    """
    List all experiments with pagination and sorting.
    """
    db = ExperimentDB()

    results = db.query_best(
        metric=sort_by,
        strategy=strategy,
        min_trades=0,
        top_k=1000 # Fetch more to support pagination loosely
    )

    # Apply python sorting if needed (though query_best does DESC)
    if not sort_desc:
        results.reverse()

    # Pagination
    start_idx = (page - 1) * limit
    end_idx = start_idx + limit
    paginated_results = results[start_idx:end_idx]

    # Add has_viz field
    response_items = []
    for r in paginated_results:
        # Check if viz folder exists
        viz_path = RESULTS_DIR / "viz" / r['run_id']
        has_viz = viz_path.exists() and (viz_path / "trades.jsonl").exists()

        item = r.copy()
        item['has_viz'] = has_viz
        response_items.append(item)

    return {
        "items": response_items,
        "total": len(results), # Approximate total since we capped at 1000
        "page": page,
        "limit": limit
    }

@router.get("/{run_id}", response_model=ExperimentResponse)
async def get_experiment(run_id: str):
    """Get details of a specific experiment."""
    db = ExperimentDB()
    record = db.get_run(run_id)
    if not record:
        raise HTTPException(status_code=404, detail="Experiment not found")

    # Check viz
    viz_path = RESULTS_DIR / "viz" / run_id
    has_viz = viz_path.exists() and (viz_path / "trades.jsonl").exists()

    record['has_viz'] = has_viz
    return record


# Helper for robust deletion on Windows
def on_rm_error(func, path, exc_info):
    """
    Error handler for ``shutil.rmtree``.

    If the error is due to an access error (read only file)
    it attempts to add write permission and then retries.

    If the error is for another reason it re-raises the error.
    
    Usage : ``shutil.rmtree(path, onerror=on_rm_error)``
    """
    import stat
    # Is the error an access error?
    if not os.access(path, os.W_OK):
        os.chmod(path, stat.S_IWUSR)
        func(path)
    else:
        raise

@router.delete("/clear")
async def clear_experiments():
    """Delete ALL experiments and artifacts."""
    db = ExperimentDB()
    
    # 1. Clear DB
    try:
        db.delete_all()
    except Exception as e:
        print(f"Error clearing DB: {e}")

    # 2. Clear run directories from RESULTS_DIR
    # This ensures we delete everything, including _test runs and viz
    if RESULTS_DIR.exists():
        for item in RESULTS_DIR.iterdir():
            # Skip the database file itself
            if item.name == "experiments.db":
                continue
                
            try:
                if item.is_dir():
                    shutil.rmtree(item, onerror=on_rm_error)
                else:
                    item.unlink()
            except Exception as e:
                print(f"Failed to delete {item}: {e}")

    # Recreate viz directory as it's expected by some components
    (RESULTS_DIR / "viz").mkdir(exist_ok=True)
    
    return {"success": True, "message": "All experiments cleared"}

@router.delete("/{run_id}")
async def delete_experiment(run_id: str):
    """Delete an experiment and its artifacts."""
    db = ExperimentDB()

    # Delete from DB
    deleted = db.delete_run(run_id)

    # Delete artifacts
    viz_path = RESULTS_DIR / "viz" / run_id
    if viz_path.exists():
        shutil.rmtree(viz_path)

    # Also check base results dir
    base_path = RESULTS_DIR / run_id
    if base_path.exists():
        shutil.rmtree(base_path)

    if not deleted and not viz_path.exists() and not base_path.exists():
        raise HTTPException(status_code=404, detail="Experiment not found")

    return {"success": True, "message": f"Deleted run {run_id}"}

class VisualizeRequest(BaseModel):
    pass # No params needed, just re-run using stored config

@router.post("/{run_id}/visualize")
async def visualize_experiment(run_id: str):
    """
    Re-run an experiment with visualization enabled.
    This effectively converts a 'Light' run to a 'Viz' run.
    """
    import subprocess
    import sys
    import tempfile

    db = ExperimentDB()
    record = db.get_run(run_id)
    if not record:
        raise HTTPException(status_code=404, detail="Experiment not found")

    config = record.get('config', {})
    recipe = config.get('recipe')
    start_date = config.get('start_date')
    end_date = config.get('end_date')

    if not recipe:
        raise HTTPException(status_code=400, detail="Experiment config missing recipe")

    # Create temp recipe file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(recipe, f, indent=2)
        recipe_path = f.name

    try:
        # Run run_recipe.py WITHOUT --light
        cmd = [
            sys.executable, "-m", "scripts.run_recipe",
            "--recipe", recipe_path,
            "--out", run_id, # Overwrite same ID
            "--start-date", start_date,
            "--end-date", end_date
        ]

        print(f"Re-running for viz: {' '.join(cmd)}")

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=str(RESULTS_DIR.parent) # Assuming cwd is repo root
        )

        if result.returncode != 0:
            raise HTTPException(status_code=500, detail=f"Re-run failed: {result.stderr}")

        return {"success": True, "message": f"Visualization generated for {run_id}"}

    finally:
        # Cleanup
        try:
            from pathlib import Path
            Path(recipe_path).unlink()
        except:
            pass

@router.get("/summary")
async def experiments_summary():
    """Get aggregate stats by strategy."""
    try:
        db = ExperimentDB()
        return db.list_strategies()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

```

### src/server/infer_routes.py

```python
"""
Simple Inference Endpoint

POST /infer - Takes price window, runs CNN, returns signal
"""

import torch
import torch.nn as nn
import numpy as np
from pathlib import Path
from typing import Dict, Any, Optional
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/infer", tags=["inference"])

# Cached model
_model = None
_model_path = None


class InferRequest(BaseModel):
    """Request for CNN inference."""
    bars: list  # List of {open, high, low, close, volume}
    model_path: Optional[str] = None  # Direct path (legacy)
    model_id: Optional[str] = None    # Lookup from DB (preferred)
    threshold: float = 0.2


class InferResponse(BaseModel):
    """Response from CNN inference."""
    triggered: bool
    direction: str  # LONG, SHORT, or NONE
    probability: float
    entry_price: float
    stop_price: float
    tp_price: float
    
    
class IFVG4ClassCNN(nn.Module):
    """CNN for 4-class IFVG pattern detection (embedded copy)."""
    
    def __init__(self, input_channels: int = 5, seq_length: int = 30, num_classes: int = 4):
        super().__init__()
        
        self.features = nn.Sequential(
            nn.Conv1d(input_channels, 32, kernel_size=3, padding=1),
            nn.BatchNorm1d(32),
            nn.ReLU(),
            nn.MaxPool1d(2),
            
            nn.Conv1d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm1d(64),
            nn.ReLU(),
            nn.MaxPool1d(2),
            
            nn.Conv1d(64, 128, kernel_size=3, padding=1),
            nn.BatchNorm1d(128),
            nn.ReLU(),
            nn.AdaptiveAvgPool1d(1),
        )
        
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.4),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(32, num_classes),
        )
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.features(x)
        return self.classifier(x)


def load_model(model_path: Path):
    """Load model with auto-detected architecture."""
    global _model, _model_path
    
    if _model is not None and _model_path == str(model_path):
        return _model
    
    checkpoint = torch.load(model_path, map_location='cpu', weights_only=False)
    
    if 'model_state_dict' in checkpoint:
        state_dict = checkpoint['model_state_dict']
    else:
        state_dict = checkpoint
    
    # Detect model architecture by looking at layer sizes
    # IFVG4ClassCNN: features.0.weight is (32, 5, 3), classifier.6.weight exists
    # SimpleCNN: features.0.weight is (16, 5, 3), classifier.4.weight exists
    
    if 'features.0.weight' in state_dict:
        first_conv_out = state_dict['features.0.weight'].shape[0]
        
        if first_conv_out == 32 and 'classifier.7.weight' in state_dict:
            # This is IFVG4ClassCNN (8 classifier layers: 0-7)
            num_classes = state_dict['classifier.7.weight'].shape[0]
            model = IFVG4ClassCNN(num_classes=num_classes)
        elif first_conv_out == 16 and 'classifier.4.weight' in state_dict:
            # This is SimpleCNN
            num_classes = state_dict['classifier.4.weight'].shape[0]
            from src.models.fusion import SimpleCNN
            model = SimpleCNN(num_classes=num_classes)
        else:
            raise ValueError(f"Unknown CNN architecture: first_conv_out={first_conv_out}")
    else:
        raise ValueError("Unknown model architecture - no features.0.weight found")
    
    model.load_state_dict(state_dict)
    model.eval()
    
    _model = model
    _model_path = str(model_path)
    
    return model

# UNIFIED FEATURE ENGINE - Single source of truth
# This replaces the duplicate normalize_window that was here before
from src.features.engine import normalize_ohlcv_window, compute_atr, bars_to_model_input

def normalize_window(ohlcv_array):
    """
    Normalize OHLCV window - DELEGATES TO UNIFIED ENGINE.
    
    Kept for backwards compatibility, but all new code should use:
        from src.features.engine import normalize_ohlcv_window
    """
    return normalize_ohlcv_window(ohlcv_array)



@router.post("", response_model=InferResponse)
async def infer(request: InferRequest) -> InferResponse:
    """
    Run model inference on price window.
    
    Supports both CNN (.pth) and other model types via ModelRegistry plugin system.
    
    Bars should be last 120 1-minute bars (or at least 30).
    Returns whether to trigger a trade and at what levels.
    
    Model can be specified by:
    - model_id: Lookup from ModelRegistry (preferred, uses plugin wrappers)
    - model_path: Direct path (legacy, CNN only)
    """
    from src.core.registries import ModelRegistry
    
    if len(request.bars) < 30:
        raise HTTPException(400, f"Need at least 30 bars, got {len(request.bars)}")
    
    # Prepare bars array for models
    bars_array = np.array([
        [b['open'], b['high'], b['low'], b['close'], b.get('volume', 0)]
        for b in request.bars[-30:]
    ])
    
    current_price = request.bars[-1]['close']
    atr = abs(request.bars[-1]['high'] - request.bars[-1]['low']) * 2
    if atr < 0.5: atr = current_price * 0.001
    
    # Try ModelRegistry first (plugin system)
    model_id = None
    if request.model_path:
        # Extract model_id from path: "models/puller_xgb_4class.json" -> "puller_xgb_4class"
        model_id = Path(request.model_path).stem
    
    try:
        registered_models = {m.model_id: m for m in ModelRegistry.list_all()}
        if model_id and model_id in registered_models:
            # Use plugin wrapper
            wrapper = ModelRegistry.create(model_id, model_path=str(request.model_path))
            
            # Call wrapper.predict() with bars
            result = wrapper.predict({'bars': request.bars, 'ohlcv': normalize_window(bars_array)})
            
            # Extract response from wrapper result
            triggered = result.get('triggered', False)
            direction = result.get('direction', 'NONE')
            prob = result.get('long_win_prob', 0) if direction == 'LONG' else result.get('short_win_prob', 0)
            
            # Apply threshold
            if prob < request.threshold:
                triggered = False
                direction = 'NONE'
            
            # Calculate levels
            if direction == 'LONG':
                entry = current_price
                stop = entry - (2 * atr)
                tp = entry + (4 * atr)
            elif direction == 'SHORT':
                entry = current_price
                stop = entry + (2 * atr)
                tp = entry - (4 * atr)
            else:
                entry = current_price
                stop = 0
                tp = 0
            
            return InferResponse(
                triggered=triggered,
                direction=direction,
                probability=round(prob, 4),
                entry_price=round(entry, 2),
                stop_price=round(stop, 2),
                tp_price=round(tp, 2)
            )
    except Exception as e:
        # Fall through to legacy CNN loading
        print(f"[infer] ModelRegistry failed: {e}, falling back to legacy")
        pass
    
    # Legacy path: direct PyTorch model loading
    # Resolve model path and architecture config
    arch_config = None
    
    if request.model_id:
        # Lookup model path AND architecture from ExperimentDB
        from src.storage import ExperimentDB
        db = ExperimentDB()
        experiment = db.get_run(f"train_{request.model_id}")
        if experiment:
            if experiment.get('model_path'):
                model_path = Path(experiment['model_path'])
            else:
                model_path = Path(f"models/{request.model_id}.pth")
            # Extract architecture config if available
            config = experiment.get('config', {})
            if 'architecture' in config:
                arch_config = config['architecture']
        else:
            # Fallback: try direct path in models/
            model_path = Path(f"models/{request.model_id}.pth")
    elif request.model_path:
        model_path = Path(request.model_path)
    else:
        # Default fallback
        model_path = Path("models/ifvg_4class_cnn.pth")
    
    if not model_path.exists():
        raise HTTPException(404, f"Model not found: {model_path}")
    
    
    # Load model
    model = load_model(model_path)
    
    # Convert bars to numpy array - use last 30 bars (training used 30)
    bars_to_use = request.bars[-30:] if len(request.bars) >= 30 else request.bars
    bars_array = np.array([
        [b['open'], b['high'], b['low'], b['close'], b.get('volume', 0)]
        for b in bars_to_use
    ])
    
    # Normalize - returns (5, length) already
    x_norm = normalize_window(bars_array)
    
    # To tensor: (1, channels, length)
    x_t = torch.tensor(x_norm, dtype=torch.float32).unsqueeze(0)
    
    # For SimpleCNN, just pass the tensor
    # For FusionModel, we'd need multi-timeframe data (not available here)
    with torch.no_grad():
        if hasattr(model, 'features'):
            # SimpleCNN or IFVG4ClassCNN
            logits = model(x_t)
            probs = torch.softmax(logits, dim=-1)
        else:
            # FusionModel - would need more data, fallback
            probs = torch.tensor([[0.25, 0.25, 0.25, 0.25]])
    
    # Interpret output based on num_classes
    # 4-class model: 0=LONG_WIN, 1=LONG_LOSS, 2=SHORT_WIN, 3=SHORT_LOSS
    # 2-class model: 0=LOSS, 1=WIN (original binary)
    num_classes = probs.shape[-1]
    
    current_price = request.bars[-1]['close']
    atr = abs(request.bars[-1]['high'] - request.bars[-1]['low']) * 2  # Simple ATR proxy
    if atr < 0.5: atr = current_price * 0.001  # Fallback
    
    if num_classes == 4:
        # 4-class: 0=LONG_WIN, 1=LONG_LOSS, 2=SHORT_WIN, 3=SHORT_LOSS
        long_win = float(probs[0, 0])
        long_loss = float(probs[0, 1])
        short_win = float(probs[0, 2])
        short_loss = float(probs[0, 3])
        
        # Trigger on the WIN class with highest probability
        if long_win >= request.threshold and long_win > short_win:
            triggered = True
            direction = 'LONG'
            prob = long_win
        elif short_win >= request.threshold:
            triggered = True
            direction = 'SHORT'
            prob = short_win
        else:
            triggered = False
            direction = 'NONE'
            prob = max(long_win, short_win)
    elif num_classes == 2:
        # Binary: 0=LOSS, 1=WIN
        prob = float(probs[0, 1])
        triggered = prob >= request.threshold
        direction = 'LONG' if triggered else 'NONE'  # Assume binary model is Long-only
    else:
        # 3-class or other: assume 0=No, 1=Long, 2=Short
        long_prob = float(probs[0, 1])
        short_prob = float(probs[0, 2]) if num_classes > 2 else 0
        
        if long_prob >= request.threshold and long_prob > short_prob:
            triggered = True
            direction = 'LONG'
            prob = long_prob
        elif short_prob >= request.threshold:
            triggered = True
            direction = 'SHORT'
            prob = short_prob
        else:
            triggered = False
            direction = 'NONE'
            prob = max(long_prob, short_prob)
    
    # Calculate levels
    if direction == 'LONG':
        entry = current_price
        stop = entry - (2 * atr)
        tp = entry + (4 * atr)
    elif direction == 'SHORT':
        entry = current_price
        stop = entry + (2 * atr)
        tp = entry - (4 * atr)
    else:
        entry = current_price
        stop = 0
        tp = 0
    
    return InferResponse(
        triggered=triggered,
        direction=direction,
        probability=round(prob, 4),
        entry_price=round(entry, 2),
        stop_price=round(stop, 2),
        tp_price=round(tp, 2)
    )

```

### src/server/main.py

```python
"""
MLang2 API Server
FastAPI backend serving viz data and proxying agent chat to Gemini.

Run:
    uvicorn src.server.main:app --reload --port 8000
"""

import os
import sys
import json
import re
from pathlib import Path
from typing import List, Dict, Any, Optional
import shutil
import tempfile
import subprocess
from datetime import datetime, timedelta
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import httpx

from src.config import RESULTS_DIR
from src.data.loader import load_continuous_contract
from src.data.resample import resample_all_timeframes
from src.core.tool_registry import ToolRegistry, ToolCategory

# Import agent tools to register them
import src.tools.agent_tools  # noqa: F401
import src.tools.analysis_tools  # noqa: F401 - Registers analysis tools
import src.core.strategy_tool  # noqa: F401 - Registers CompositeStrategyRunner
