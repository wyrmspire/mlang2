"""
NewTestGapFillScanner Strategy
Generated by scripts/create_strategy.py
"""

from src.policy.scanners import Scanner, ScanResult
from src.features.state import MarketState
from src.features.pipeline import FeatureBundle
from typing import Dict, Any

class NewTestGapFillScanner(Scanner):
    """
    TODO: Add description of your strategy here.
    """

    @property
    def scanner_id(self) -> str:
        return "new_test_gap_fill"

    def scan(self, state: MarketState, features: FeatureBundle) -> ScanResult:
        """
        Check for entry conditions on every bar.
        
        Available data:
        - state.timestamp, state.current_price, state.last_close
        - features.indicators (RSI, EMA, etc.)
        """
        
        # Custom Logic for Gap Fill
        # If open is significantly below previous close, buy to fill gap
        prev_close = features.levels.pdc
        curr_open = state.current_price
        
        triggered = False
        context = {}
        
        if prev_close > 0 and curr_open < prev_close * 0.995: # 0.5% gap down
            triggered = True
            context = {
                "direction": "LONG",
                "reason": "Gap Fill Long",
                "entry_price": state.current_price
            }

        return ScanResult(
            scanner_id=self.scanner_id,
            triggered=triggered,
            context=context,
            score=1.0 if triggered else 0.0
        )
